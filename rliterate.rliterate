{
"children":[
{
"children":[
{
"children":[],
"id":"7f14d9ec23c0425c89039ea68dfdac16",
"paragraphs":[
{
"id":"d37ed809b1ea44cf9205e4cad963bcb5",
"text":"* smallest federated wiki inspired the factory and the editing workflow\n* leo and smallest federated wiki inspired TOC and seeing a single page/node at a time",
"type":"list"
}
],
"title":"Main GUI"
},
{
"children":[],
"id":"3ad55f274f724ebab8cea5d5c63d8dc0",
"paragraphs":[
{
"id":"0e82720d665642f69b79b2e35234cf99",
"text":"RLiterate is a reading and thinking tool. The following features support that.",
"type":"text"
},
{
"id":"394402716d9b45e195298f16a6d4c8d5",
"text":"Hoisting a page in the table of contents allows you to **focus on a subset** of the document.",
"type":"text"
},
{
"id":"359a25b33d5645b69be21e54b5b78abe",
"text":"Openining a page and all immediate children (double click on a page in the table of contents) allows you to read a subset of the document **breath first**. It's like reading only the first paragraph in an entire book.",
"type":"text"
}
],
"title":"Reading tool"
},
{
"children":[],
"id":"6c34776183394824824be039e65de531",
"paragraphs":[
{
"id":"65ead2c5a424420b8b5368c046f2af52",
"text":"Describe how code paragraphs enable literate programming.",
"type":"text"
}
],
"title":"Literate programming"
}
],
"id":"600aa145cf474a6aa732a4c4edb5f44b",
"paragraphs":[
{
"id":"a37b9d0368034afaa5013d3d4fa33b7a",
"text":"This chapter gives an overview what RLiterate looks like.",
"type":"text"
}
],
"title":"A tour of RLiterate"
},
{
"children":[
{
"children":[],
"id":"9b46f6326dda497fabbc1ef7f5247422",
"paragraphs":[
{
"id":"de7976f7066f4ec598fc13ba35e4ac67",
"text":"So I decided to build a prototype to learn what such a tool might be like.\n",
"type":"text"
},
{
"id":"7bf0be74a55e42e4aa192f2b4d8df297",
"text":"First I came up with a document model where pages were organized in a hierarchy and where each page had paragraphs that could be of different types. This idea was stolen from [Smallest Federated Wiki](https://en.wikipedia.org/wiki/Smallest_Federated_Wiki). The code paragraph would allow for literate programming. I also envisioned other paragraph types that would allow for more interaction. Perhaps one paragraph type could be [Graphviz](http://graphviz.org/) code, and when edited, a generated graph would appear instead of the code.",
"type":"text"
},
{
"id":"45375c646cae41e5889e450c800ca1d3",
"text":"After coming up with a document model, I implement a GUI that would allow editing such documents. This GUI had to be first class as it would be the primary way to read and author documents.",
"type":"text"
},
{
"id":"a28ef005c5fb46f882d33121b9e94b3b",
"text":"At a certain point I had all the functionality in place for doing literate programming. Then I imported all the code into an RLiterate document (previously it was written as a single Python file) and started extracting pieces and adding prose to explain the program. As I went along I noticed features I was lacking.",
"type":"text"
}
],
"title":"The prototype"
},
{
"children":[],
"id":"f496615acbe44223a64e1db1fc154b12",
"paragraphs":[
{
"id":"fe04c847a4f54b3e80e49e60f650119e",
"text":"To me, the most central idea in literate programming is that we should write programs for other humans. Only secondary for the machine. I find code easier to understand if I can understand it in isolated pieces. One example where it is difficult to isolate a piece without literate programming is test code. Usually the test code is located in one file, and the implementation in another. To fully understand the piece it is useful to both read the tests and the implementation. To do this we have to find this related information in two unrelated files. I wrote about this problem in 2003 in [Related things are not kept together](http://rickardlindberg.me/writing/reflections-on-programming/2013-02-24-related-things-are-not-kept-together/). Literate programming allows us to present the test and the implementation in the same place, yet have the different pieces written to different files. The compiler might require that they are in separate files, but with literate programming, we care first about the other human that will read our code, and only second about the compiler.",
"type":"text"
},
{
"id":"683d2cd7bded485cb4659cd40065ea93",
"text":"Another argument for literate programming is to express the \"why\". Why is this code here? Timothy Daly talks about it in his talk [Literate Programming in the Large](https://www.youtube.com/watch?v=Av0PQDVTP4A). He also argues that programmers must change the mindset from wring a program to writing a book. Some more can be read here: http://axiom-developer.org/axiom-website/litprog.html.",
"type":"text"
},
{
"id":"ead08e336d8749f79b82f0093feeeb94",
"text":"Some more resources about literate programming:",
"type":"text"
},
{
"id":"ab0371f11dd4469d982a7ea0ef617eb6",
"text":"* https://www.youtube.com/watch?v=5V1ynVyud4M\n  \"Eve\" by Chris Granger\n\n* http://eve-lang.com/deepdives/literate.html\n\n* https://software-carpentry.org/blog/2011/03/literate-programming.html",
"type":"list"
}
],
"title":"Why literate programming?"
},
{
"children":[],
"id":"e836cd0edf4a4b66ab8dd1e5d7fbbea3",
"paragraphs":[
{
"id":"624299d364c54ef9afeedd42e7cca57b",
"text":"I stumbled across [ProjecturED](http://projectured.org/). It is similar to RLiterate in the sense that it is an editor for richer documents. Not just text. The most interesting aspect for me is that a variable name exists in one place, but can be rendered in multiple. So a rename is really simple. With RLiterate, you have to do a search and replace. But with ProjecturED you just change the name and it replicates everywhere. This is an attractive feature and is made possible by the different document model. Probably RLiterate can never support that because a completely different approach needs to be taken, but it is an interesting project to investigate further.\n",
"type":"text"
}
],
"title":"Similar tools"
}
],
"id":"95150c4f0d92428bbeef4ae5a865398d",
"paragraphs":[
{
"id":"491cebce6de04e43a2695237c1359ca4",
"text":"Many things inspired RLiterate, but the initial thought was triggered by the paper [Active Essays on the Web](http://www.vpri.org/pdf/tr2009002_active_essays.pdf). In it they talk about embedding code in documents that the reader can interact with. They also mention [Literate programming](https://en.wikipedia.org/wiki/Literate_programming) as having a related goal.",
"type":"text"
},
{
"id":"54adfab3c5a2436d95fda4bdd95849c7",
"text":"At the time I was working on a program that I thought would be nice to express in this way. I wanted to write an article about the program and have the code for the program embedded in the article. I could have used a literate programming tool for this, but the interactive aspect of active essays made me think that a tool would be much more powerful if the document could be edited \"live\", similar to WYSIWYG editors. Literate programming tools I were aware of worked by editing plain text files with a special syntax for code and documentation blocks, thus lacking the interactive aspect.",
"type":"text"
}
],
"title":"Background"
},
{
"children":[
{
"children":[
{
"children":[],
"id":"8ab608f28a5046548963649371cab5fe",
"paragraphs":[
{
"id":"4cea9ae964e344c990fcf98f9baa6bd0",
"text":"The main frame lays out two widgets horizontally: the table of contents and the workspace. It also creates the project from the specified file path.",
"type":"text"
},
{
"id":"1184388e07e149eea4b71458b275b38b",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class MainFrame(wx.Frame):\n\n    def __init__(self, filepath):\n        wx.Frame.__init__(self, None)\n        project = Project(filepath)\n        workspace = Workspace(self, project)\n        toc = TableOfContents(self, project)\n        sizer = wx.BoxSizer(wx.HORIZONTAL)\n        sizer.Add(toc, flag=wx.EXPAND, proportion=0)\n        sizer.Add(workspace, flag=wx.EXPAND, proportion=1)\n        self.SetSizerAndFit(sizer)\n",
"type":"code"
}
],
"title":"Main frame"
},
{
"children":[
{
"children":[
{
"children":[],
"id":"49b2e6c578264b24a860b0172a9ac3a3",
"paragraphs":[
{
"id":"77b6cddc2a2946249d6c2cbae7134ed1",
"text":"The table of contents widget lays out two components in a vertical container: the unhoist button and the page container.",
"type":"text"
},
{
"id":"811a46cc4115441eb7d9fb27cd4b9916",
"path":[
"rliterate.py",
"<<classes>>",
"<<TableOfContents>>"
],
"text":"def _render(self):\n    self.sizer = wx.BoxSizer(wx.VERTICAL)\n    self.SetSizer(self.sizer)\n    self.SetBackgroundColour((255, 255, 255))\n    self._re_render()\n\ndef _re_render(self):\n    self.drop_points = []\n    self.sizer.Clear(True)\n    self._render_unhoist_button()\n    self._render_page_container()\n    self.Layout()",
"type":"code"
},
{
"id":"8cf1468ca45b41d4a2d0f2e8de91c35d",
"text":"The unhoist button (only shown if a page has been hoisted):",
"type":"text"
},
{
"id":"87836442b7824a8891244f5c8e9dc07d",
"path":[
"rliterate.py",
"<<classes>>",
"<<TableOfContents>>"
],
"text":"def _render_unhoist_button(self):\n    if self.project.get_hoisted_page() is not None:\n        button = wx.Button(self, label=\"unhoist\")\n        button.Bind(\n            wx.EVT_BUTTON,\n            lambda event: self.project.set_hoisted_page(None)\n        )\n        self.sizer.Add(button, flag=wx.EXPAND)\n",
"type":"code"
},
{
"id":"48e403ac69b5492bb09ff41381d77b8f",
"text":"The page container is a scrolling container that contains a set of rows representing pages. Each row is appropriately intendent to create the illusion of a tree.",
"type":"text"
},
{
"id":"89783cf4c0cc40f5a3c8a706be39b056",
"path":[
"rliterate.py",
"<<classes>>",
"<<TableOfContents>>"
],
"text":"def _render_page_container(self):\n    self.page_sizer = wx.BoxSizer(wx.VERTICAL)\n    self.page_container = CompactScrolledWindow(self)\n    self.page_container.SetSizer(self.page_sizer)\n    self.sizer.Add(self.page_container, flag=wx.EXPAND, proportion=1)\n    self._render_page(self.project.get_page(self.project.get_hoisted_page()))\n\ndef _render_page(self, page, indentation=0):\n    is_collapsed = self.project.is_collapsed(page.id)\n    self.page_sizer.Add(\n        TableOfContentsRow(self.page_container, self.project, page, indentation),\n        flag=wx.EXPAND\n    )\n    divider = Divider(self.page_container, padding=0, height=2)\n    self.page_sizer.Add(\n        divider,\n        flag=wx.EXPAND\n    )\n    if is_collapsed or len(page.children) == 0:\n        before_page_id = None\n    else:\n        before_page_id = page.children[0].id\n    self.drop_points.append(TableOfContentsDropPoint(\n        divider=divider,\n        indentation=indentation+1,\n        parent_page_id=page.id,\n        before_page_id=before_page_id\n    ))\n    if not is_collapsed:\n        for child, next_child in pairs(page.children):\n            divider = self._render_page(child, indentation+1)\n            self.drop_points.append(TableOfContentsDropPoint(\n                divider=divider,\n                indentation=indentation+1,\n                parent_page_id=page.id,\n                before_page_id=None if next_child is None else next_child.id\n            ))\n    return divider\n",
"type":"code"
},
{
"id":"f1e8ef353eac47dd93dc76d86efcce6e",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class TableOfContentsDropPoint(object):\n\n    def __init__(self, divider, indentation, parent_page_id, before_page_id):\n        self.divider = divider\n        self.indentation = indentation\n        self.parent_page_id = parent_page_id\n        self.before_page_id = before_page_id\n\n    def x_distance_to(self, x):\n        left_padding = TableOfContentsButton.SIZE+1+TableOfContentsRow.BORDER\n        span_x_center = left_padding + TableOfContentsRow.INDENTATION_SIZE * (self.indentation + 1.5)\n        return abs(span_x_center - x)\n\n    def y_distance_to(self, y):\n        return abs(self.divider.Position.y + self.divider.Size[1]/2 - y)\n\n    def Show(self):\n        self.divider.Show(sum([\n            TableOfContentsRow.BORDER,\n            TableOfContentsButton.SIZE,\n            1,\n            self.indentation*TableOfContentsRow.INDENTATION_SIZE,\n        ]))\n\n    def Hide(self):\n        self.divider.Hide()",
"type":"code"
}
],
"title":"Rendering"
},
{
"children":[],
"id":"99a2a81b38164293b9ad9287b33bfbbb",
"paragraphs":[
{
"id":"84b201f687224953ad89da562eb6b1cb",
"text":"Inside the table of contents, pages can be dragged and drop. The drag is initiated in the row widget and handled in the table of contents widget.",
"type":"text"
},
{
"id":"2d626c4528eb406c983b5d64851d10c9",
"path":[
"rliterate.py",
"<<classes>>",
"<<TableOfContents>>",
"<<__init__>>"
],
"text":"self.SetDropTarget(TableOfContentsDropTarget(self, self.project))",
"type":"code"
},
{
"id":"0985fad6f1be429096835a728941d44f",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class TableOfContentsDropTarget(DropPointDropTarget):\n\n    def __init__(self, toc, project):\n        DropPointDropTarget.__init__(self, toc, \"page\")\n        self.project = project\n\n    def OnDataDropped(self, dropped_page, drop_point):\n        self.project.move_page(\n            page_id=dropped_page[\"page_id\"],\n            parent_page_id=drop_point.parent_page_id,\n            before_page_id=drop_point.before_page_id\n        )\n",
"type":"code"
},
{
"id":"dc9eb0e4255e48c9999944caa48a60bd",
"text":"The DropPointDropTarget requires FindClosestDropPoint to be defined on the target object. Here it is:",
"type":"text"
},
{
"id":"f32123cdfe6f49239b35ab893b621d51",
"path":[
"rliterate.py",
"<<classes>>",
"<<TableOfContents>>"
],
"text":"def FindClosestDropPoint(self, screen_pos):\n    client_pos = self.page_container.ScreenToClient(screen_pos)\n    if self.page_container.HitTest(client_pos) == wx.HT_WINDOW_INSIDE:\n        scroll_pos = (scroll_x, scroll_y) = self.page_container.CalcUnscrolledPosition(client_pos)\n        y_distances = defaultdict(list)\n        for drop_point in self.drop_points:\n            y_distances[drop_point.y_distance_to(scroll_y)].append(drop_point)\n        if y_distances:\n            return min(\n                y_distances[min(y_distances.keys())],\n                key=lambda drop_point: drop_point.x_distance_to(scroll_x)\n            )\n",
"type":"code"
}
],
"title":"Dropping pages"
}
],
"id":"f0c6aa103d2a45aa8737d7d964e860bc",
"paragraphs":[
{
"id":"d7196568704f4228956b0166a06b2ab5",
"text":"The main table of contents widget listens for changes to a project (only events related to changes in the document and the layout of the table of contents) and then re-renders itself.",
"type":"text"
},
{
"id":"19989e3da6004e61b58d3a570b52d9fc",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class TableOfContents(wx.Panel):\n    <<TableOfContents>>\n",
"type":"code"
},
{
"id":"985f041571444f9c9c62cb0905e144c8",
"path":[
"rliterate.py",
"<<classes>>",
"<<TableOfContents>>"
],
"text":"def __init__(self, parent, project):\n    wx.Panel.__init__(self, parent, size=(250, -1))\n    self.project_listener = Listener(\n        self._re_render_from_event,\n        \"document\", \"layout.toc\"\n    )\n    self.SetProject(project)\n    <<__init__>>\n    self._render()\n\ndef SetProject(self, project):\n    self.project = project\n    self.project_listener.set_observable(self.project)\n",
"type":"code"
},
{
"id":"a1ec06a34b604de99e5102a82fe00f1b",
"text":"This seems to be needed for some reason:",
"type":"text"
},
{
"id":"05d68cdb54b84316862f03915d6030a4",
"path":[
"rliterate.py",
"<<classes>>",
"<<TableOfContents>>"
],
"text":"def _re_render_from_event(self, event):\n    wx.CallAfter(self._re_render)",
"type":"code"
}
],
"title":"Main widget"
},
{
"children":[],
"id":"116c471cbc1d41588168321c18c99386",
"paragraphs":[
{
"id":"f0f947ef43f0460ab970e56b50dfb339",
"text":"The row widget renders the page title at the appropriate indentation. If the page has children, an expand/collapse widget is also rendered to the left of the title.",
"type":"text"
},
{
"id":"4edadec964c141f7a33b7cc691d6e00b",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class TableOfContentsRow(wx.Panel):\n\n    def __init__(self, parent, project, page, indentation):\n        wx.Panel.__init__(self, parent)\n        self.project = project\n        self.page = page\n        self.indentation = indentation\n        self._render()\n\n    <<TableOfContentsRow>>\n",
"type":"code"
},
{
"id":"0b017f41b129456d9969b8b4115f3b6c",
"text":"Rendering lays out expand/collapse button (if the page has children) and the page title in a horizontal sizer:",
"type":"text"
},
{
"id":"e7222f9d1f2e4c6dbcdee098b3f75ca4",
"path":[
"rliterate.py",
"<<classes>>",
"<<TableOfContentsRow>>"
],
"text":"BORDER = 2\nINDENTATION_SIZE = 16\n\ndef _render(self):\n    self.sizer = wx.BoxSizer(wx.HORIZONTAL)\n    self.sizer.Add((self.indentation*self.INDENTATION_SIZE, 1))\n    if self.page.children:\n        button = TableOfContentsButton(self, self.project, self.page)\n        self.sizer.Add(button, flag=wx.EXPAND|wx.LEFT, border=self.BORDER)\n    else:\n        self.sizer.Add((TableOfContentsButton.SIZE+1+self.BORDER, 1))\n    text = wx.StaticText(self)\n    text.SetLabelText(self.page.title)\n    self.sizer.Add(text, flag=wx.ALL, border=self.BORDER)\n    self.SetSizer(self.sizer)\n    self.Bind(wx.EVT_ENTER_WINDOW, self._on_enter_window)\n    self.Bind(wx.EVT_LEAVE_WINDOW, self._on_leave_window)\n    for helper in [MouseEventHelper(self), MouseEventHelper(text)]:\n        helper.OnClick = self._on_click\n        helper.OnDoubleClick = self._on_double_click\n        helper.OnRightClick = self._on_right_click\n        helper.OnDrag = self._on_drag\n",
"type":"code"
},
{
"id":"2f458d6548464fc88dbde361469cfcba",
"text":"Event handlers:",
"type":"text"
},
{
"id":"38c32e72a6514307926cf2ae728dbbf6",
"path":[
"rliterate.py",
"<<classes>>",
"<<TableOfContentsRow>>"
],
"text":"def _on_click(self):\n    self.project.open_pages([self.page.id], column_index=0)\n\ndef _on_double_click(self):\n    page_ids = [self.page.id]\n    for child in self.project.get_page(self.page.id).children:\n        page_ids.append(child.id)\n    self.project.open_pages(page_ids, column_index=0)\n\ndef _on_right_click(self):\n    menu = PageContextMenu(self.project, self.page)\n    self.PopupMenu(menu)\n    menu.Destroy()\n\ndef _on_drag(self):\n    data = RliterateDataObject(\"page\", {\n        \"page_id\": self.page.id,\n    })\n    drag_source = wx.DropSource(self)\n    drag_source.SetData(data)\n    result = drag_source.DoDragDrop(wx.Drag_DefaultMove)\n\ndef _on_enter_window(self, event):\n    self.SetBackgroundColour((240, 240, 240))\n\ndef _on_leave_window(self, event):\n    self.SetBackgroundColour((255, 255, 255))\n",
"type":"code"
}
],
"title":"Row widget"
},
{
"children":[],
"id":"159632cc0cfd436ab33cb97a335306b4",
"paragraphs":[
{
"id":"e91427b852754cb682eb63c881d490f4",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class TableOfContentsButton(wx.Panel):\n\n    SIZE = 16\n\n    def __init__(self, parent, project, page):\n        wx.Panel.__init__(self, parent, size=(self.SIZE+1, -1))\n        self.Bind(wx.EVT_PAINT, self.OnPaint)\n        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)\n        self.project = project\n        self.page = page\n        self.SetCursor(wx.StockCursor(wx.CURSOR_HAND))\n\n    def OnLeftDown(self, event):\n        self.project.toggle_collapsed(self.page.id)\n\n    def OnPaint(self, event):\n        dc = wx.GCDC(wx.PaintDC(self))\n        dc.SetBrush(wx.BLACK_BRUSH)\n        render = wx.RendererNative.Get()\n        (w, h) = self.Size\n        render.DrawTreeItemButton(\n            self,\n            dc,\n            (0, (h-self.SIZE)/2, self.SIZE, self.SIZE),\n            flags=0 if self.project.is_collapsed(self.page.id) else wx.CONTROL_EXPANDED\n        )\n",
"type":"code"
}
],
"title":"Expand/Collapse widget"
},
{
"children":[],
"id":"308ae25fdd69497baef7c40ddb8e9ad3",
"paragraphs":[
{
"id":"8ca885b27025476996cabd09eedae341",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class PageContextMenu(wx.Menu):\n\n    def __init__(self, project, page):\n        wx.Menu.__init__(self)\n        self.project = project\n        self.page = page\n        self.child_ids = [page.id]+[child.id for child in page.children]\n        self._create_menu()\n\n    def _create_menu(self):\n        self.Bind(\n            wx.EVT_MENU,\n            lambda event: self.project.open_pages([self.page.id], column_index=0),\n            self.Append(wx.NewId(), \"Open\")\n        )\n        self.Bind(\n            wx.EVT_MENU,\n            lambda event: self.project.open_pages([self.page.id]),\n            self.Append(wx.NewId(), \"Open append\")\n        )\n        self.Bind(\n            wx.EVT_MENU,\n            lambda event: self.project.open_pages(self.child_ids, column_index=0),\n            self.Append(wx.NewId(), \"Open with children\")\n        )\n        self.Bind(\n            wx.EVT_MENU,\n            lambda event: self.project.open_pages(self.child_ids),\n            self.Append(wx.NewId(), \"Open with children append\")\n        )\n        self.AppendSeparator()\n        self.Bind(\n            wx.EVT_MENU,\n            lambda event: self.project.add_page(parent_id=self.page.id),\n            self.Append(wx.NewId(), \"Add child\")\n        )\n        self.AppendSeparator()\n        self.Bind(\n            wx.EVT_MENU,\n            lambda event: self.project.set_hoisted_page(self.page.id),\n            self.Append(wx.NewId(), \"Hoist\")\n        )\n        self.AppendSeparator()\n        self.Bind(\n            wx.EVT_MENU,\n            lambda event: self.project.delete_page(self.page.id),\n            self.Append(wx.NewId(), \"Delete\")\n        )\n",
"type":"code"
}
],
"title":"Page context menu"
}
],
"id":"c456e147b7b745ed80697c4faeb02bcb",
"paragraphs":[
{
"id":"7fa7bfb6863d487b9989cb454fed762d",
"text":"The table of contents shows the outline of the document. It allows only subtrees to be shown (hoisting) and allows subtrees to be expanded/collapsed. It also provides navigation functions to allow pages to be opened.",
"type":"text"
}
],
"title":"Table of contents"
},
{
"children":[
{
"children":[
{
"children":[],
"id":"3f0fc44a9eba4a5cbcae5da3ee5d8925",
"paragraphs":[
{
"id":"246a23a170164f1c91e73f877b824930",
"text":"Rendering a workspace means laying out a set of column widgets horizontally. Columns are filled with page containers.",
"type":"text"
},
{
"id":"d5dd19fb0dac4111b42932071e6a0c2f",
"path":[
"rliterate.py",
"<<classes>>",
"<<Workspace>>"
],
"text":"def _render(self):\n    self.SetBackgroundColour((200, 200, 200))\n    self.sizer = wx.BoxSizer(wx.HORIZONTAL)\n    self.sizer.AddSpacer(PAGE_PADDING)\n    self.SetSizer(self.sizer)\n    self.columns = []\n    self._re_render()\n\ndef _re_render(self):\n    self._ensure_num_columns(len(self.project.columns))\n    for index, page_ids in enumerate(self.project.columns):\n        self.columns[index].SetPages(self.project, page_ids)\n    self.Parent.Layout()\n\ndef _ensure_num_columns(self, num):\n    while len(self.columns) > num:\n        self.columns.pop(-1).Destroy()\n    while len(self.columns) < num:\n        self.columns.append(self._add_column())\n\ndef _add_column(self):\n    column = Column(self)\n    self.sizer.Add(column, flag=wx.EXPAND)\n    return column\n",
"type":"code"
},
{
"id":"db2d5c4540ff42baa0cc1232134f310b",
"text":"`Layout` is called on the parent. Otherwise scrollbars don't seem to update appropriately.",
"type":"text"
},
{
"id":"859451cd2a664a1698affbc6ea11fa46",
"text":"On removing widgets [Removing a widget from its wxPython parent](https://stackoverflow.com/a/41064558):",
"type":"text"
},
{
"id":"c881d2542f834261b1060e001e991f85",
"text":"Widgets will remove themselves from the sizer when they are destroyed, so yes, it is redundant. Also, widgets will remove themselves from the parent's child list, so calling `RemoveChild` is also redundant. IOW, the call to `window.Destroy()` will be sufficient to remove the widget and its resources, and to do the necessary clean-ups in the parent and the sizer.",
"type":"quote"
},
{
"id":"fe799c6fd8484a9095d88a7f3faaf4bd",
"text":"wx.CallAfter seems to be needed to correctly update scrollbars on an event notification. Resizing the window also works.",
"type":"text"
},
{
"id":"8e4e54c3a9fe453cbb9e6298c51a700e",
"path":[
"rliterate.py",
"<<classes>>",
"<<Workspace>>"
],
"text":"def _re_render_from_event(self, event):\n    wx.CallAfter(self._re_render)",
"type":"code"
}
],
"title":"Rendering"
},
{
"children":[],
"id":"e056bc29d02647a0a67d03693ddc4c7d",
"paragraphs":[
{
"id":"d983d5dcddcd4e67a5c68f77b22dff83",
"text":"Inside a workspace, paragraphs can be dragged and dropped. The drag is handled in the paragraph widget, but the drop is handled in the workspace widget.",
"type":"text"
},
{
"id":"e05a55e327d042329bfce331b38762b6",
"path":[
"rliterate.py",
"<<classes>>",
"<<Workspace>>",
"<<__init__>>"
],
"text":"self.SetDropTarget(WorkspaceDropTarget(self, self.project))",
"type":"code"
},
{
"id":"79f48335418c42c1a622c691514415ab",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class WorkspaceDropTarget(DropPointDropTarget):\n\n    def __init__(self, workspace, project):\n        DropPointDropTarget.__init__(self, workspace, \"paragraph\")\n        self.project = project\n\n    def OnDataDropped(self, dropped_paragraph, drop_point):\n        self.project.move_paragraph(\n            source_page=dropped_paragraph[\"page_id\"],\n            source_paragraph=dropped_paragraph[\"paragraph_id\"],\n            target_page=drop_point.page_id,\n            before_paragraph=drop_point.next_paragraph_id\n        )\n",
"type":"code"
},
{
"id":"bd195234d44049b6b0073b835bce34ba",
"text":"The DropPointDropTarget requires FindClosestDropPoint to be defined on the target object. Here it is:",
"type":"text"
},
{
"id":"9c426c9c3e10484ba02da8bf2b2ff94d",
"path":[
"rliterate.py",
"<<classes>>",
"<<Workspace>>"
],
"text":"def FindClosestDropPoint(self, screen_pos):\n    return find_first(\n        self.columns,\n        lambda column: column.FindClosestDropPoint(screen_pos)\n    )",
"type":"code"
}
],
"title":"Dropping paragraphs"
}
],
"id":"e2de7fc557e542a7ac8fde91b7651736",
"paragraphs":[
{
"id":"6a9ac9606ee5499694f3236ccabf1127",
"text":"The main workspace widget is a horizontal scrolling container containing column widgets.",
"type":"text"
},
{
"id":"b5c9d88523ed45f1bf811a1d849f729b",
"text":"The workspace is re-rendered whenever relevant parts of the project changes.",
"type":"text"
},
{
"id":"a9f5b20c21c244d583d9b4f808ac8753",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Workspace(CompactScrolledWindow):\n    <<Workspace>>\n",
"type":"code"
},
{
"id":"0af9efe473c140fd93a87c18050ab77e",
"path":[
"rliterate.py",
"<<classes>>",
"<<Workspace>>"
],
"text":"def __init__(self, parent, project):\n    CompactScrolledWindow.__init__(self, parent, style=wx.HSCROLL)\n    self.project_listener = Listener(\n        self._re_render_from_event,\n        \"document\",\n        \"layout.workspace\"\n    )\n    self.SetProject(project)\n    <<__init__>>\n    self._render()\n\ndef SetProject(self, project):\n    self.project = project\n    self.project_listener.set_observable(self.project)\n",
"type":"code"
}
],
"title":"Main widget"
},
{
"children":[],
"id":"b5ccbbfc0b6445a3a19a5c3dc39daa81",
"paragraphs":[
{
"id":"5d9d79b33aa44d6ca21b8a760fd09dc3",
"text":"The column widget is a vertical scrolling container containing page containers.",
"type":"text"
},
{
"id":"cb982a3129f940f18cd4bc9237d4c8f8",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Column(CompactScrolledWindow):\n\n    def __init__(self, parent):\n        CompactScrolledWindow.__init__(\n            self,\n            parent,\n            style=wx.VSCROLL,\n            size=(PAGE_BODY_WIDTH+2*CONTAINER_BORDER+PAGE_PADDING, -1)\n        )\n        self._page_ids = []\n        self._setup_layout()\n\n    def _setup_layout(self):\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.SetSizer(self.sizer)\n\n    def SetPages(self, project, page_ids):\n        self.containers = []\n        self.sizer.Clear(True)\n        self.sizer.AddSpacer(PAGE_PADDING)\n        for page_id in page_ids:\n            if project.get_page(page_id) is not None:\n                container = PageContainer(self, project, page_id)\n                self.sizer.Add(\n                    container,\n                    flag=wx.RIGHT|wx.BOTTOM|wx.EXPAND,\n                    border=PAGE_PADDING\n                )\n                self.containers.append(container)\n        if page_ids != self._page_ids:\n            self.Scroll(0, 0)\n            self._page_ids = page_ids\n\n    def FindClosestDropPoint(self, screen_pos):\n        return find_first(\n            self.containers,\n            lambda container: container.FindClosestDropPoint(screen_pos)\n        )\n",
"type":"code"
}
],
"title":"Column widget"
},
{
"children":[],
"id":"1164b94ba82c476897ce18fc1b70a5b8",
"paragraphs":[
{
"id":"bb9393f32b254e4c8d629a90e706a5a1",
"text":"The page container widget draws a box with border. Inside the box a page widget is rendered.",
"type":"text"
},
{
"id":"29a948082ed3467395fb08fcbc0ad7c9",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class PageContainer(wx.Panel):\n\n    def __init__(self, parent, project, page_id):\n        wx.Panel.__init__(self, parent)\n        self.project = project\n        self.page_id = page_id\n        self._render()\n\n    def _render(self):\n        self.SetBackgroundColour((150, 150, 150))\n        self.inner_sizer = wx.BoxSizer(wx.VERTICAL)\n        self.inner_container = wx.Panel(self)\n        self.inner_container.SetBackgroundColour((255, 255, 255))\n        self.inner_container.SetSizer(self.inner_sizer)\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(\n            self.inner_container,\n            flag=wx.EXPAND|wx.RIGHT|wx.BOTTOM,\n            border=SHADOW_SIZE\n        )\n        self.SetSizer(self.sizer)\n        self.inner_sizer.AddSpacer(CONTAINER_BORDER)\n        self.page = Page(self.inner_container, self.project, self.page_id)\n        self.inner_sizer.Add(\n            self.page,\n            flag=wx.LEFT|wx.RIGHT|wx.BOTTOM|wx.EXPAND,\n            border=CONTAINER_BORDER\n        )\n\n    def FindClosestDropPoint(self, screen_pos):\n        return self.page.FindClosestDropPoint(screen_pos)\n",
"type":"code"
}
],
"title":"Page container widget"
},
{
"children":[
{
"children":[],
"id":"553a9a3715bc4c18b143572352fc922e",
"paragraphs":[
{
"id":"0d23868db06847a1800d8ef8659887f3",
"path":[
"rliterate.py",
"<<classes>>",
"<<Page>>"
],
"text":"def _render(self):\n    self.sizer = wx.BoxSizer(wx.VERTICAL)\n    self.SetSizer(self.sizer)\n    self.drop_points = []\n    page = self.project.get_page(self.page_id)\n    divider = self._render_paragraph(Title(self, self.project, page))\n    for paragraph in page.paragraphs:\n        self.drop_points.append(PageDropPoint(\n            divider=divider,\n            page_id=self.page_id,\n            next_paragraph_id=paragraph.id\n        ))\n        divider = self._render_paragraph({\n            \"text\": Text,\n            \"quote\": Quote,\n            \"list\": List,\n            \"code\": Code,\n            \"factory\": Factory,\n        }[paragraph.type](self, self.project, self.page_id, paragraph))\n    self.drop_points.append(PageDropPoint(\n        divider=divider,\n        page_id=self.page_id,\n        next_paragraph_id=None\n    ))\n    self._render_add_button()\n\ndef _render_paragraph(self, paragraph):\n    self.sizer.Add(\n        paragraph,\n        flag=wx.EXPAND,\n        border=PARAGRAPH_SPACE\n    )\n    divider = Divider(self, padding=(PARAGRAPH_SPACE-3)/2, height=3)\n    self.sizer.Add(\n        divider,\n        flag=wx.EXPAND,\n        border=PARAGRAPH_SPACE\n    )\n    return divider\n\ndef _render_add_button(self):\n    add_button = wx.BitmapButton(\n        self,\n        bitmap=wx.ArtProvider.GetBitmap(\n            wx.ART_ADD_BOOKMARK,\n            wx.ART_BUTTON,\n            (16, 16)\n        ),\n        style=wx.NO_BORDER\n    )\n    add_button.Bind(wx.EVT_BUTTON, self._on_add_button)\n    self.sizer.Add(\n        add_button,\n        flag=wx.TOP|wx.ALIGN_RIGHT,\n        border=PARAGRAPH_SPACE\n    )\n\ndef _on_add_button(self, event):\n    self.project.add_paragraph(self.page_id)\n",
"type":"code"
},
{
"id":"ceac79cd0d6f400ba9d4be19e8e79672",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class PageDropPoint(object):\n\n    def __init__(self, divider, page_id, next_paragraph_id):\n        self.divider = divider\n        self.page_id = page_id\n        self.next_paragraph_id = next_paragraph_id\n\n    def y_distance_to(self, y):\n        return abs(self.divider.Position.y + self.divider.Size[1]/2 - y)\n\n    def Show(self):\n        self.divider.Show()\n\n    def Hide(self):\n        self.divider.Hide()",
"type":"code"
}
],
"title":"Rendering"
},
{
"children":[],
"id":"9d0b1c1dc456410180edbb1a45fb56cb",
"paragraphs":[
{
"id":"92c41fd20a1d4511ad864bbfd315aa88",
"path":[
"rliterate.py",
"<<classes>>",
"<<Page>>"
],
"text":"def FindClosestDropPoint(self, screen_pos):\n    client_pos = (client_x, client_y) = self.ScreenToClient(screen_pos)\n    if self.HitTest(client_pos) == wx.HT_WINDOW_INSIDE:\n        return min_or_none(\n            self.drop_points,\n            key=lambda drop_point: drop_point.y_distance_to(client_y)\n        )\n",
"type":"code"
}
],
"title":"Dropping paragraphs"
}
],
"id":"eb6360eff66245daa2fe09b04bbbc120",
"paragraphs":[
{
"id":"1994c9452817497c92e1d51cf6a050bc",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Page(wx.Panel):\n\n    def __init__(self, parent, project, page_id):\n        wx.Panel.__init__(self, parent)\n        self.project = project\n        self.page_id = page_id\n        self._render()\n\n    <<Page>>\n",
"type":"code"
}
],
"title":"Page"
},
{
"children":[],
"id":"f1137543026a4319a6a9e2ce5d0f3d5e",
"paragraphs":[
{
"id":"24ce3a2a4785432ea263e18f55bfa106",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Title(Editable):\n\n    def __init__(self, parent, project, page):\n        self.project = project\n        self.page = page\n        Editable.__init__(self, parent)\n\n    def CreateView(self):\n        self.Font = create_font(size=16)\n        view = RichTextDisplay(\n            self,\n            self.project,\n            [Fragment(self.page.title)],\n            max_width=PAGE_BODY_WIDTH\n        )\n        MouseEventHelper.bind(\n            [view],\n            double_click=lambda: post_edit_start(view)\n        )\n        return view\n\n    def CreateEdit(self):\n        edit = wx.TextCtrl(self, style=wx.TE_PROCESS_ENTER, value=self.page.title)\n        edit.Bind(\n            wx.EVT_TEXT_ENTER,\n            lambda _: self.project.edit_page(self.page.id, {\"title\": self.edit.Value})\n        )\n        return edit\n",
"type":"code"
}
],
"title":"Title"
},
{
"children":[
{
"children":[],
"id":"1688f5eee57645a68af81fa5f02a1560",
"paragraphs":[
{
"id":"7446201f4c6d46f3b33d94f4f36503d2",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Text(ParagraphBase):\n\n    def CreateView(self):\n        return TextView(\n            self,\n            self.project,\n            self.paragraph.formatted_text,\n            self\n        )\n\n    def CreateEdit(self):\n        return TextEdit(\n            self,\n            self.project,\n            self.paragraph,\n            self.view\n        )\n",
"type":"code"
},
{
"id":"7771215ada52498a87873fe98b069d66",
"text":"The view:",
"type":"text"
},
{
"id":"bb3cb1f635d4476a9f796aa6d9f3845d",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class TextView(RichTextDisplay):\n\n    def __init__(self, parent, project, fragments, base):\n        RichTextDisplay.__init__(\n            self,\n            parent,\n            project,\n            fragments,\n            line_height=1.2,\n            max_width=PAGE_BODY_WIDTH\n        )\n        MouseEventHelper.bind(\n            [self],\n            drag=base.DoDragDrop,\n            right_click=base.ShowContextMenu,\n            double_click=lambda: post_edit_start(self),\n            move=self._change_cursor,\n            click=self._follow_link\n        )\n        self.default_cursor = self.GetCursor()\n        self.link_fragment = None\n\n    def _change_cursor(self, position):\n        fragment = self.GetFragment(position)\n        if fragment is not None and fragment.token == Token.RLiterate.Link:\n            self.SetCursor(wx.StockCursor(wx.CURSOR_HAND))\n            self.link_fragment = fragment\n        else:\n            self.SetCursor(self.default_cursor)\n            self.link_fragment = None\n\n    def _follow_link(self):\n        if self.link_fragment is not None:\n            webbrowser.open(self.link_fragment.extra[\"url\"])\n",
"type":"code"
},
{
"id":"0dfb3ea73ab040ec9ce4a0c9eecaba27",
"text":"The editor:",
"type":"text"
},
{
"id":"7cc47c031e0242aa98658e84c51e5418",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class TextEdit(MultilineTextCtrl):\n\n    def __init__(self, parent, project, paragraph, view):\n        MultilineTextCtrl.__init__(\n            self,\n            parent,\n            value=paragraph.text,\n            size=(-1, view.Size[1])\n        )\n        self.project = project\n        self.paragraph = paragraph\n        self.Bind(wx.EVT_CHAR, self._on_char)\n\n    def _on_char(self, event):\n        if event.KeyCode == wx.WXK_CONTROL_S:\n            self._save()\n        elif event.KeyCode == wx.WXK_RETURN and event.ControlDown():\n            self._save()\n        else:\n            event.Skip()\n\n    def _save(self):\n        self.project.edit_paragraph(\n            self.paragraph.id,\n            {\"text\": self.Value}\n        )\n",
"type":"code"
}
],
"title":"Text"
},
{
"children":[],
"id":"7a79cf8e89e54505a3096182df3969de",
"paragraphs":[
{
"id":"2f672cd613c84c2c9bbd113672956163",
"text":"A quote paragraph is the same as a text paragraph but the view is rendered indented.",
"type":"text"
},
{
"id":"bd65127796664140bf2823ed50b27f87",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Quote(Text):\n\n    INDENT = 20\n\n    def CreateView(self):\n        view = wx.Panel(self)\n        sizer = wx.BoxSizer(wx.HORIZONTAL)\n        sizer.AddSpacer(self.INDENT)\n        sizer.Add(\n            TextView(\n                view,\n                self.project,\n                self.paragraph.formatted_text,\n                self\n            ),\n            flag=wx.EXPAND,\n            proportion=1\n        )\n        view.SetSizer(sizer)\n        return view\n",
"type":"code"
}
],
"title":"Quote"
},
{
"children":[],
"id":"f1a44b0e5e824e7baba3a2ca256b243b",
"paragraphs":[
{
"id":"50911d0525dd4f38adc52e1108754007",
"text":"A list paragraph is the same as a text paragraph but renders differently. With bullets and indentation.",
"type":"text"
},
{
"id":"8d490d7f70f74eea91eee4feb06f777c",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class List(Text):\n\n    def CreateView(self):\n        view = wx.Panel(self)\n        sizer = wx.BoxSizer(wx.VERTICAL)\n        self.add_items(view, sizer, self.paragraph.item.children, self.paragraph.item.child_type)\n        view.SetSizer(sizer)\n        return view\n\n    def add_items(self, view, sizer, items, child_type, indent=0):\n        for index, item in enumerate(items):\n            inner_sizer = wx.BoxSizer(wx.HORIZONTAL)\n            inner_sizer.AddSpacer(20*indent)\n            if child_type == \"ordered\":\n                bullet = \"{}.\".format(index + 1)\n            else:\n                bullet = u\"\\u2022\"\n            inner_sizer.Add(wx.StaticText(self, label=bullet+\" \"))\n            inner_sizer.Add(\n                TextView(\n                    view,\n                    self.project,\n                    item.formatted_text,\n                    self\n                )\n            )\n            sizer.Add(inner_sizer, flag=wx.EXPAND)\n            self.add_items(view, sizer, item.children, item.child_type, indent+1)\n",
"type":"code"
}
],
"title":"List"
},
{
"children":[],
"id":"91969238a9d24673aec5bc1c8bc8bd7b",
"paragraphs":[
{
"id":"1e77735cb0fe409683695b5339204a23",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Code(ParagraphBase):\n\n    def CreateView(self):\n        return CodeView(self, self.project, self.paragraph, self)\n\n    def CreateEdit(self):\n        return CodeEditor(self, self.project, self.paragraph, self.view)\n",
"type":"code"
},
{
"id":"0db2311ab3404ba0a7096f9f28d9a38e",
"text":"The view:",
"type":"text"
},
{
"id":"397eb97b4763418c9e8e4a8cbcb75a72",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class CodeView(wx.Panel):\n\n    BORDER = 0\n    PADDING = 5\n\n    def __init__(self, parent, project, paragraph, base):\n        wx.Panel.__init__(self, parent)\n        self.project = project\n        self.base = base\n        self.Font = create_font(monospace=True)\n        self.vsizer = wx.BoxSizer(wx.VERTICAL)\n        self.vsizer.Add(\n            self._create_path(paragraph),\n            flag=wx.ALL|wx.EXPAND, border=self.BORDER\n        )\n        self.vsizer.Add(\n            self._create_code(paragraph),\n            flag=wx.LEFT|wx.BOTTOM|wx.RIGHT|wx.EXPAND, border=self.BORDER\n        )\n        self.SetSizer(self.vsizer)\n        self.SetBackgroundColour((243, 236, 219))\n\n    def _create_path(self, paragraph):\n        panel = wx.Panel(self)\n        panel.SetBackgroundColour((248, 241, 223))\n        text = RichTextDisplay(\n            panel,\n            self.project,\n            insert_between(\n                Fragment(\" / \"),\n                [Fragment(x, token=pygments.token.Token.RLiterate.Strong) for x in paragraph.path]\n            ),\n            max_width=PAGE_BODY_WIDTH-2*self.PADDING\n        )\n        sizer = wx.BoxSizer(wx.HORIZONTAL)\n        sizer.Add(text, flag=wx.ALL|wx.EXPAND, border=self.PADDING)\n        panel.SetSizer(sizer)\n        MouseEventHelper.bind(\n            [panel, text],\n            double_click=self._post_paragraph_edit_start,\n            drag=self.base.DoDragDrop,\n            right_click=self.base.ShowContextMenu\n        )\n        return panel\n\n    def _create_code(self, paragraph):\n        panel = wx.Panel(self)\n        panel.SetBackgroundColour((253, 246, 227))\n        body = RichTextDisplay(\n            panel,\n            self.project,\n            paragraph.formatted_text,\n            max_width=PAGE_BODY_WIDTH-2*self.PADDING\n        )\n        sizer = wx.BoxSizer(wx.HORIZONTAL)\n        sizer.Add(body, flag=wx.ALL|wx.EXPAND, border=self.PADDING, proportion=1)\n        panel.SetSizer(sizer)\n        MouseEventHelper.bind(\n            [panel, body],\n            double_click=self._post_paragraph_edit_start,\n            drag=self.Parent.DoDragDrop,\n            right_click=self.Parent.ShowContextMenu\n        )\n        return panel\n\n    def _post_paragraph_edit_start(self):\n        post_edit_start(self)\n",
"type":"code"
},
{
"id":"7b087c5b9fd0460088e21aa2dc47567f",
"path":[
"rliterate.py",
"<<functions>>"
],
"text":"def insert_between(separator, items):\n    result = []\n    for i, item in enumerate(items):\n        if i > 0:\n            result.append(separator)\n        result.append(item)\n    return result\n",
"type":"code"
},
{
"id":"8d090339156c477e9d4e39c825412f6d",
"text":"The editor:",
"type":"text"
},
{
"id":"f7d289a713724b6a94edb96f4d823e90",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class CodeEditor(wx.Panel):\n\n    BORDER = 1\n    PADDING = 3\n\n    def __init__(self, parent, project, paragraph, view):\n        wx.Panel.__init__(self, parent)\n        self.Font = create_font(monospace=True)\n        self.project = project\n        self.paragraph = paragraph\n        self.view = view\n        self.vsizer = wx.BoxSizer(wx.VERTICAL)\n        self.vsizer.Add(\n            self._create_path(paragraph),\n            flag=wx.ALL|wx.EXPAND, border=self.BORDER\n        )\n        self.vsizer.Add(\n            self._create_code(paragraph),\n            flag=wx.LEFT|wx.BOTTOM|wx.RIGHT|wx.EXPAND, border=self.BORDER\n        )\n        self.vsizer.Add(\n            self._create_save(),\n            flag=wx.LEFT|wx.BOTTOM|wx.RIGHT|wx.EXPAND, border=self.BORDER\n        )\n        self.SetSizer(self.vsizer)\n\n    def _create_path(self, paragraph):\n        self.path = wx.TextCtrl(\n            self,\n            value=\" / \".join(paragraph.path)\n        )\n        return self.path\n\n    def _create_code(self, paragraph):\n        self.text = MultilineTextCtrl(\n            self,\n            value=paragraph.text,\n            size=(-1, self.view.Size[1])\n        )\n        return self.text\n\n    def _create_save(self):\n        button = wx.Button(\n            self,\n            label=\"Save\"\n        )\n        self.Bind(wx.EVT_BUTTON, self._on_save)\n        return button\n\n    def _on_save(self, event):\n        self.project.edit_paragraph(self.paragraph.id, {\n            \"path\": self.path.Value.split(\" / \"),\n            \"text\": self.text.Value,\n        })\n",
"type":"code"
}
],
"title":"Code"
},
{
"children":[],
"id":"e0ecf028bb904931882c2fe4694d87e2",
"paragraphs":[
{
"id":"e36c95740f9840f09b3819aa281fedd6",
"text":"A factory can not be edited, so only the view is provided.",
"type":"text"
},
{
"id":"5e54a4dc1241440c84a432b13ff071d9",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Factory(ParagraphBase):\n\n    def CreateView(self):\n        view = wx.Panel(self)\n        MouseEventHelper.bind(\n            [view],\n            drag=self.DoDragDrop,\n            right_click=self.ShowContextMenu\n        )\n        view.SetBackgroundColour((240, 240, 240))\n        self.vsizer = wx.BoxSizer(wx.VERTICAL)\n        self.hsizer = wx.BoxSizer(wx.HORIZONTAL)\n        self.vsizer.Add(\n            wx.StaticText(view, label=\"Factory\"),\n            flag=wx.TOP|wx.ALIGN_CENTER,\n            border=PARAGRAPH_SPACE\n        )\n        self.vsizer.Add(\n            self.hsizer,\n            flag=wx.TOP|wx.ALIGN_CENTER,\n            border=PARAGRAPH_SPACE\n        )\n        text_button = wx.Button(self, label=\"Text\")\n        text_button.Bind(wx.EVT_BUTTON, self._on_text_button)\n        self.hsizer.Add(text_button, flag=wx.ALL, border=2)\n        code_button = wx.Button(self, label=\"Code\")\n        code_button.Bind(wx.EVT_BUTTON, self._on_code_button)\n        self.hsizer.Add(code_button, flag=wx.ALL, border=2)\n        self.vsizer.AddSpacer(PARAGRAPH_SPACE)\n        view.SetSizer(self.vsizer)\n        return view\n\n    def _on_text_button(self, event):\n        self.project.edit_paragraph(\n            self.paragraph.id,\n            {\"type\": \"text\", \"text\": \"Enter text here...\"}\n        )\n\n    def _on_code_button(self, event):\n        self.project.edit_paragraph(\n            self.paragraph.id,\n            {\"type\": \"code\", \"path\": [], \"text\": \"Enter code here...\"}\n        )\n",
"type":"code"
}
],
"title":"Factory"
},
{
"children":[],
"id":"31681e4c6b0e44de98f2c05a7718170a",
"paragraphs":[
{
"id":"39ada32fde3245e7baac32cb839fb4e2",
"path":[
"rliterate.py",
"<<base classes>>"
],
"text":"class ParagraphBase(Editable):\n\n    def __init__(self, parent, project, page_id, paragraph):\n        self.project = project\n        self.page_id = page_id\n        self.paragraph = paragraph\n        Editable.__init__(self, parent)\n\n    def DoDragDrop(self):\n        data = RliterateDataObject(\"paragraph\", {\n            \"page_id\": self.page_id,\n            \"paragraph_id\": self.paragraph.id,\n        })\n        drag_source = wx.DropSource(self)\n        drag_source.SetData(data)\n        result = drag_source.DoDragDrop(wx.Drag_DefaultMove)\n\n    def ShowContextMenu(self):\n        menu = ParagraphContextMenu()\n        self._add_base(menu)\n        self.PopupMenu(menu)\n        menu.Destroy()\n\n    def _add_base(self, menu):\n        menu.AppendItem(\n            \"Delete\",\n            lambda: self.project.delete_paragraph(\n                page_id=self.page_id,\n                paragraph_id=self.paragraph.id\n            )\n        )\n        menu.AppendItem(\n            \"Edit in gvim\",\n            lambda: self.project.edit_paragraph(\n                self.paragraph.id,\n                {\"text\": edit_in_gvim(self.paragraph.text, self.paragraph.filename)}\n            )\n        )\n        menu.AppendSeparator()\n        menu.AppendItem(\n            \"To quote\",\n            lambda: self.project.edit_paragraph(\n                self.paragraph.id,\n                {\"type\": \"quote\"}\n            )\n        )\n        menu.AppendItem(\n            \"To text\",\n            lambda: self.project.edit_paragraph(\n                self.paragraph.id,\n                {\"type\": \"text\"}\n            )\n        )\n        menu.AppendItem(\n            \"To list\",\n            lambda: self.project.edit_paragraph(\n                self.paragraph.id,\n                {\"type\": \"list\"}\n            )\n        )\n",
"type":"code"
},
{
"id":"e054ba1012de4fb9af5685d26f2682b8",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class ParagraphContextMenu(wx.Menu):\n\n    def AppendItem(self, text, fn):\n        self.Bind(\n            wx.EVT_MENU,\n            lambda event: fn(),\n            self.Append(wx.NewId(), text)\n        )\n",
"type":"code"
}
],
"title":"Paragraph base"
}
],
"id":"2280405b81c741cfa73d2629f1ef4b4b",
"paragraphs":[],
"title":"Paragraphs"
},
{
"children":[],
"id":"33398a32e9c0460d98d0ada485f19067",
"paragraphs":[
{
"id":"e8f297cc43c84f3589a18191088fd308",
"text":"Editables are widgets that contain a view and an editor. When the editor is opened, the view is hidden and the editor is shown in its place. The editor is opened by posting an `EditStart` event from the view. This is typically done from a double click event handler.",
"type":"text"
},
{
"id":"615380bc2ce240ada8493970597c68c8",
"text":"This class should be inherited, and the `CreateView` method should be implemented. `CreateEdit` must also be inherited if `EditStart` events are expected.",
"type":"text"
},
{
"id":"79cd58077311436295ce672e07703388",
"path":[
"rliterate.py",
"<<base classes 1>>"
],
"text":"class Editable(wx.Panel):\n\n    def __init__(self, parent):\n        wx.Panel.__init__(self, parent)\n        self.view = self.CreateView()\n        self.sizer = wx.BoxSizer(wx.VERTICAL)\n        self.sizer.Add(self.view, flag=wx.EXPAND, proportion=1)\n        self.SetSizer(self.sizer)\n        self.view.Bind(EVT_EDIT_START, self.OnEditStart)\n\n    def OnEditStart(self, event):\n        self.edit = self.CreateEdit()\n        self.edit.SetFocus()\n        self.sizer.Add(self.edit, flag=wx.EXPAND, proportion=1)\n        self.sizer.Hide(self.view)\n        self.GetTopLevelParent().Layout()\n",
"type":"code"
},
{
"id":"3e66b8a4eb5d4aba9fbfa7b6c4c025d5",
"path":[
"rliterate.py",
"<<constants>>"
],
"text":"EditStart, EVT_EDIT_START = wx.lib.newevent.NewCommandEvent()",
"type":"code"
},
{
"id":"cbf3b69a55b14a9ba8a1543e153dba86",
"path":[
"rliterate.py",
"<<functions>>"
],
"text":"def post_edit_start(control):\n    wx.PostEvent(control, EditStart(0))\n",
"type":"code"
}
],
"title":"Editables"
}
],
"id":"4dd60465575c4297a25813f0478f15f9",
"paragraphs":[
{
"id":"9c4aa635d5b841ff8cf2a0648a6aff6d",
"text":"The workspace shows pages in the document. It is organized in columns, and each column can show multiple pages. The pages can also be edited from the workspace.",
"type":"text"
}
],
"title":"Workspace"
},
{
"children":[
{
"children":[],
"id":"de31abba62b94730be1653a4b9e76f44",
"paragraphs":[
{
"id":"6786b60a42784b3785585aebae5064cd",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class RliterateDataObject(wx.CustomDataObject):\n\n    def __init__(self, kind, json=None):\n        wx.CustomDataObject.__init__(self, \"rliterate/{}\".format(kind))\n        if json is not None:\n            self.set_json(json)\n\n    def set_json(self, data):\n        self.SetData(json.dumps(data))\n\n    def get_json(self):\n        return json.loads(self.GetData())",
"type":"code"
}
],
"title":"RLiterate data object"
},
{
"children":[],
"id":"1d623dc7a566477786012227b9790d81",
"paragraphs":[
{
"id":"e93d2e5b66864933ab1e184634965f9f",
"text":"A drop target that can work with windows that supports FindClosestDropPoint.",
"type":"text"
},
{
"id":"1ae68af41cdc472c848edf7b65cd9557",
"path":[
"rliterate.py",
"<<base classes>>"
],
"text":"class DropPointDropTarget(wx.DropTarget):\n\n    def __init__(self, window, kind):\n        wx.DropTarget.__init__(self)\n        self.window = window\n        self.last_drop_point = None\n        self.rliterate_data = RliterateDataObject(kind)\n        self.DataObject = self.rliterate_data\n\n    def OnDragOver(self, x, y, defResult):\n        self._hide_last_drop_point()\n        drop_point = self._find_closest_drop_point(x, y)\n        if drop_point is not None and defResult == wx.DragMove:\n            drop_point.Show()\n            self.last_drop_point = drop_point\n            return wx.DragMove\n        return wx.DragNone\n\n    def OnData(self, x, y, defResult):\n        self._hide_last_drop_point()\n        drop_point = self._find_closest_drop_point(x, y)\n        if drop_point is not None and self.GetData():\n            self.OnDataDropped(self.rliterate_data.get_json(), drop_point)\n        return defResult\n\n    def OnLeave(self):\n        self._hide_last_drop_point()\n\n    def _find_closest_drop_point(self, x, y):\n        return self.window.FindClosestDropPoint(\n            self.window.ClientToScreen((x, y))\n        )\n\n    def _hide_last_drop_point(self):\n        if self.last_drop_point is not None:\n            self.last_drop_point.Hide()\n            self.last_drop_point = None",
"type":"code"
}
],
"title":"Drop point drop target"
},
{
"children":[],
"id":"aaa60456f36c4c3cbb1d4389d3bf5352",
"paragraphs":[
{
"id":"e5b2434a29a64c10a347242181a98d3c",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Divider(wx.Panel):\n\n    def __init__(self, parent, padding=0, height=1):\n        wx.Panel.__init__(self, parent, size=(-1, height+2*padding))\n        self.line = wx.Panel(self, size=(-1, height))\n        self.line.SetBackgroundColour((255, 100, 0))\n        self.line.Hide()\n        self.hsizer = wx.BoxSizer(wx.HORIZONTAL)\n        self.vsizer = wx.BoxSizer(wx.VERTICAL)\n        self.vsizer.AddStretchSpacer(1)\n        self.vsizer.Add(self.hsizer, flag=wx.EXPAND|wx.RESERVE_SPACE_EVEN_IF_HIDDEN)\n        self.vsizer.AddStretchSpacer(1)\n        self.SetSizer(self.vsizer)\n\n    def Show(self, left_space=0):\n        self.line.Show()\n        self.hsizer.Clear(False)\n        self.hsizer.Add((left_space, 1))\n        self.hsizer.Add(self.line, flag=wx.EXPAND, proportion=1)\n        self.Layout()\n\n    def Hide(self):\n        self.line.Hide()\n        self.Layout()",
"type":"code"
}
],
"title":"Divider"
}
],
"id":"a6e8ca0aa83d4829b15c0424be259022",
"paragraphs":[],
"title":"Drag & drop"
},
{
"children":[
{
"children":[],
"id":"68bd8a9e595b4c84b10d25865d1377ff",
"paragraphs":[
{
"id":"b888370be9654c4bb270014d549139db",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class MouseEventHelper(object):\n\n    @classmethod\n    def bind(cls, windows, drag=None, click=None, right_click=None,\n             double_click=None, move=None):\n        for window in windows:\n            mouse_event_helper = cls(window)\n            if drag is not None:\n                mouse_event_helper.OnDrag = drag\n            if click is not None:\n                mouse_event_helper.OnClick = click\n            if right_click is not None:\n                mouse_event_helper.OnRightClick = right_click\n            if double_click is not None:\n                mouse_event_helper.OnDoubleClick = double_click\n            if move is not None:\n                mouse_event_helper.OnMove = move\n\n    def __init__(self, window):\n        self.down_pos = None\n        window.Bind(wx.EVT_LEFT_DOWN, self._on_left_down)\n        window.Bind(wx.EVT_MOTION, self._on_motion)\n        window.Bind(wx.EVT_LEFT_UP, self._on_left_up)\n        window.Bind(wx.EVT_LEFT_DCLICK, self._on_left_dclick)\n        window.Bind(wx.EVT_RIGHT_UP, self._on_right_up)\n\n    def OnDrag(self):\n        pass\n\n    def OnClick(self):\n        pass\n\n    def OnRightClick(self):\n        pass\n\n    def OnDoubleClick(self):\n        pass\n\n    def OnMove(self, position):\n        pass\n\n    def _on_left_down(self, event):\n        self.down_pos = event.Position\n\n    def _on_motion(self, event):\n        if self.down_pos is None:\n            self.OnMove(event.Position)\n        if self._should_drag(event.Position):\n            self.down_pos = None\n            self.OnDrag()\n\n    def _should_drag(self, pos):\n        if self.down_pos is not None:\n            diff = self.down_pos - pos\n            if abs(diff.x) > 2:\n                return True\n            if abs(diff.y) > 2:\n                return True\n        return False\n\n    def _on_left_up(self, event):\n        if self.down_pos is not None:\n            self.OnClick()\n        self.down_pos = None\n\n    def _on_left_dclick(self, event):\n        self.OnDoubleClick()\n\n    def _on_right_up(self, event):\n        self.OnRightClick()\n",
"type":"code"
}
],
"title":"Mouse event helper"
},
{
"children":[],
"id":"f2fd8440f526447fbcd4442951435021",
"paragraphs":[
{
"id":"7286b9e86d644834b949ed82e6afb3ee",
"text":"The rich text display widget displayes styled text fragments. It does so by drawing text on a DC.",
"type":"text"
},
{
"id":"5569510f0ba84a3c8c970fd81304964a",
"path":[
"rliterate.py",
"<<base classes>>"
],
"text":"class RichTextDisplay(wx.Panel):\n    <<RichTextDisplay>>\n",
"type":"code"
},
{
"id":"1b458cc32c9444d7a16d19205948b38f",
"path":[
"rliterate.py",
"<<base classes>>",
"<<RichTextDisplay>>"
],
"text":"def __init__(self, parent, project, fragments, **kwargs):\n    wx.Panel.__init__(self, parent)\n    self.project = project\n    self.fragments = fragments\n    self.line_height = kwargs.get(\"line_height\", 1)\n    self.max_width = kwargs.get(\"max_width\", 100)\n    <<__init__>>\n",
"type":"code"
},
{
"id":"44cdc54053dc4136ab337a605d8d0de8",
"text":"First, the text fragment positions are calculated. For that a DC is needed. But the positions need to be calculated before we can draw on the panel, so a temporary memory DC is created.",
"type":"text"
},
{
"id":"2c5fccea05ca4f0caa6484a1667e7980",
"path":[
"rliterate.py",
"<<base classes>>",
"<<RichTextDisplay>>",
"<<__init__>>"
],
"text":"self._set_fragments()",
"type":"code"
},
{
"id":"2d866dd174ea4e659741a72c91b59b49",
"path":[
"rliterate.py",
"<<base classes>>",
"<<RichTextDisplay>>"
],
"text":"def _set_fragments(self):\n    dc = wx.MemoryDC()\n    dc.SetFont(self.GetFont())\n    dc.SelectObject(wx.EmptyBitmap(1, 1))\n    w, h = self._calculate_fragments(dc)\n    self.SetMinSize((w, h))\n\ndef _calculate_fragments(self, dc):\n    self.draw_fragments = []\n    x = 0\n    y = 0\n    max_x, max_y = dc.GetTextExtent(\"M\")\n    line_height_pixels = int(round(dc.GetTextExtent(\"M\")[1]*self.line_height))\n    for fragment in self._newline_fragments():\n        if fragment is None:\n            x = 0\n            y += line_height_pixels\n            max_y = max(max_y, y)\n            continue\n        style = self.project.get_style(fragment.token)\n        style.apply_to_wx_dc(dc, self.GetFont())\n        w, h = dc.GetTextExtent(fragment.text)\n        if x > 0 and x+w > self.max_width:\n            x = 0\n            y += line_height_pixels\n        self.draw_fragments.append((fragment, style, wx.Rect(x, y, w, h)))\n        max_x = max(max_x, x+w)\n        max_y = max(max_y, y+line_height_pixels)\n        x += w\n    return (max_x, max_y)\n\ndef _newline_fragments(self):\n    for fragment in self.fragments:\n        if \"\\n\" in fragment.text:\n            for x in insert_between(None, fragment.text.split(\"\\n\")):\n                if x is None:\n                    yield x\n                else:\n                    for subfragment in Fragment(x, token=fragment.token, **fragment.extra).word_split():\n                        yield subfragment\n        else:\n            for subfragment in fragment.word_split():\n                yield subfragment\n",
"type":"code"
},
{
"id":"e077531deeeb4cddbf5d03713a5232fe",
"text":"Drawing the rich text is just a matter of drawing all fragments at the pre-calculated positions:",
"type":"text"
},
{
"id":"548cace182ad42d6b8b08a5065bf79e6",
"path":[
"rliterate.py",
"<<base classes>>",
"<<RichTextDisplay>>",
"<<__init__>>"
],
"text":"self.Bind(wx.EVT_PAINT, self._on_paint)",
"type":"code"
},
{
"id":"bfc4f55298ea43dba7d1a94526901cdb",
"path":[
"rliterate.py",
"<<base classes>>",
"<<RichTextDisplay>>"
],
"text":"def _on_paint(self, event):\n    dc = wx.PaintDC(self)\n    for fragment, style, box in self.draw_fragments:\n        style.apply_to_wx_dc(dc, self.GetFont())\n        dc.DrawText(fragment.text, box.X, box.Y)\n",
"type":"code"
},
{
"id":"388ab47120904655b45e8bab8c924eb2",
"text":"Some mouse move action:",
"type":"text"
},
{
"id":"4e27995451fd479f8a9528093ff49b0b",
"path":[
"rliterate.py",
"<<base classes>>",
"<<RichTextDisplay>>"
],
"text":"def GetFragment(self, position):\n    for fragment, style, box in self.draw_fragments:\n        if box.Contains(position):\n            return fragment\n",
"type":"code"
}
],
"title":"Rich text display"
},
{
"children":[],
"id":"94b57547a194415cb00feb2aaf486e27",
"paragraphs":[
{
"id":"77379e702560445c9fd31a8bb833cc65",
"text":"The default scrolling window gives extra space. See https://stackoverflow.com/a/22817659. This custom control sovles this problem.",
"type":"text"
},
{
"id":"9bf32ef3ab984aca83e6ec65321388c7",
"path":[
"rliterate.py",
"<<base classes>>"
],
"text":"class CompactScrolledWindow(wx.ScrolledWindow):\n\n    MIN_WIDTH = 200\n    MIN_HEIGHT = 200\n\n    def __init__(self, parent, style=0, size=wx.DefaultSize, step=100):\n        w, h = size\n        size = (max(w, self.MIN_WIDTH), max(h, self.MIN_HEIGHT))\n        wx.ScrolledWindow.__init__(self, parent, style=style, size=size)\n        self.Size = size\n        if style == wx.HSCROLL:\n            self.SetScrollRate(1, 0)\n            self._calc_scroll_pos = self._calc_scroll_pos_hscroll\n        elif style == wx.VSCROLL:\n            self.SetScrollRate(0, 1)\n            self._calc_scroll_pos = self._calc_scroll_pos_vscroll\n        else:\n            self.SetScrollRate(1, 1)\n            self._calc_scroll_pos = self._calc_scroll_pos_vscroll\n        self.step = step\n        self.Bind(wx.EVT_MOUSEWHEEL, self._on_mousewheel)\n\n    def _on_mousewheel(self, event):\n        x, y = self.GetViewStart()\n        delta = event.GetWheelRotation() / event.GetWheelDelta()\n        self.Scroll(*self._calc_scroll_pos(x, y, delta))\n\n    def _calc_scroll_pos_hscroll(self, x, y, delta):\n        return (x+delta*self.step, y)\n\n    def _calc_scroll_pos_vscroll(self, x, y, delta):\n        return (x, y-delta*self.step)\n",
"type":"code"
},
{
"id":"9d06f89e91354cb68c08839512d0e156",
"text":"The minimum size is set to prevent the following error:",
"type":"text"
},
{
"id":"025b7cd450434c9c98468f9f8720edc3",
"text":"(rliterate.py:23983): Gtk-CRITICAL **: gtk_box_gadget_distribute: assertion 'size >= 0' failed in GtkScrollbar",
"type":"text"
}
],
"title":"Scrolling containers"
},
{
"children":[],
"id":"44395045b3cc4dbbbf9c7b2bb20447ed",
"paragraphs":[
{
"id":"178d81fd815d441080144e48eb3176c3",
"path":[
"rliterate.py",
"<<base classes>>"
],
"text":"class MultilineTextCtrl(wx.TextCtrl):\n\n    MIN_HEIGHT = 50\n\n    def __init__(self, parent, value, size=wx.DefaultSize):\n        w, h = size\n        size = (w, max(h, self.MIN_HEIGHT))\n        wx.TextCtrl.__init__(\n            self,\n            parent,\n            style=wx.TE_MULTILINE,\n            value=value,\n            size=size\n        )\n",
"type":"code"
},
{
"id":"341dcda05dc442cea21d7dd6089318ad",
"text":"The minimum height is set to prevent the following error:",
"type":"text"
},
{
"id":"3576819cf1444641a6f721127c50e4aa",
"text":"Gtk-CRITICAL **: gtk_box_gadget_distribute: assertion 'size >= 0' failed in GtkScrollbar",
"type":"text"
}
],
"title":"Multiline text control"
}
],
"id":"5c3647a616b8495f8bebd268be84377d",
"paragraphs":[],
"title":"wxPython utilities"
},
{
"children":[],
"id":"4495f053ab2d41a2a4ec70f55e929b9f",
"paragraphs":[
{
"id":"e3e222b97d124ce0af6eba3cead75f90",
"path":[
"rliterate.py",
"<<constants>>"
],
"text":"PAGE_BODY_WIDTH = 600\nPAGE_PADDING = 13\nSHADOW_SIZE = 2\nPARAGRAPH_SPACE = 15\nCONTAINER_BORDER = PARAGRAPH_SPACE\n",
"type":"code"
}
],
"title":"Constants"
}
],
"id":"e418766e480b41b1844c8d754b3746fc",
"paragraphs":[
{
"id":"a2e1e037cb3044b2a16bb15471199701",
"text":"The main GUI is written in wxPython.",
"type":"text"
}
],
"title":"GUI wxPython"
},
{
"children":[
{
"children":[],
"id":"ce4dc071bada48bb9294c937631e0214",
"paragraphs":[
{
"id":"377391e542c6475a85cb59faffecfa47",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Document(Observable):\n\n    @classmethod\n    def from_file(cls, path):\n        return cls(path)\n\n    def __init__(self, path):\n        Observable.__init__(self)\n        self.path = path\n        self._load()\n        self._cache()\n        self.listen(lambda event: self._save())\n\n    def _cache(self):\n        self._pages = {}\n        self._parent_pages = {}\n        self._paragraphs = {}\n        self._cache_page(self.root_page)\n\n    def _cache_page(self, page, parent_page=None):\n        self._pages[page[\"id\"]] = page\n        self._parent_pages[page[\"id\"]] = parent_page\n        for paragraph in page[\"paragraphs\"]:\n            self._paragraphs[paragraph[\"id\"]] = paragraph\n        for child in page[\"children\"]:\n            self._cache_page(child, page)\n\n    def _save(self):\n        write_json_to_file(self.path, self.root_page)\n\n    def _load(self):\n        self.root_page = load_json_from_file(self.path)\n\n    <<Document>>\n\n    # Page operations\n\n    def add_page(self, title=\"New page\", parent_id=None):\n        with self.notify():\n            page = {\n                \"id\": genid(),\n                \"title\": \"New page...\",\n                \"children\": [],\n                \"paragraphs\": [],\n            }\n            parent_page = self._pages[parent_id]\n            parent_page[\"children\"].append(page)\n            self._pages[page[\"id\"]] = page\n            self._parent_pages[page[\"id\"]] = parent_page\n\n    def delete_page(self, page_id):\n        with self.notify():\n            page = self._pages[page_id]\n            parent_page = self._parent_pages[page_id]\n            index = index_with_id(parent_page[\"children\"], page_id)\n            parent_page[\"children\"].pop(index)\n            self._pages.pop(page_id)\n            self._parent_pages.pop(page_id)\n            for child in reversed(page[\"children\"]):\n                parent_page[\"children\"].insert(index, child)\n                self._parent_pages[child[\"id\"]] = parent_page\n\n    def move_page(self, page_id, parent_page_id, before_page_id):\n        with self.notify():\n            if page_id == before_page_id:\n                return\n            parent = self._pages[parent_page_id]\n            while parent is not None:\n                if parent[\"id\"] == page_id:\n                    return\n                parent = self._parent_pages[parent[\"id\"]]\n            parent = self._parent_pages[page_id]\n            page = parent[\"children\"].pop(index_with_id(parent[\"children\"], page_id))\n            new_parent = self._pages[parent_page_id]\n            self._parent_pages[page_id] = new_parent\n            if before_page_id is None:\n                new_parent[\"children\"].append(page)\n            else:\n                new_parent[\"children\"].insert(\n                    index_with_id(new_parent[\"children\"], before_page_id),\n                    page\n                )\n\n    def edit_page(self, page_id, data):\n        with self.notify():\n            self._pages[page_id].update(data)\n\n    # Paragraph operations\n\n    def add_paragraph(self, page_id, before_id=None):\n        with self.notify():\n            paragraph = {\n                \"id\": genid(),\n                \"type\": \"factory\",\n                \"text\":\n                \"factory\",\n            }\n            self._pages[page_id][\"paragraphs\"].append(paragraph)\n            self._paragraphs[paragraph[\"id\"]] = paragraph\n\n    def move_paragraph(self, source_page, source_paragraph, target_page, before_paragraph):\n        with self.notify():\n            if (source_page == target_page and\n                source_paragraph == before_paragraph):\n                return\n            paragraph = self.delete_paragraph(source_page, source_paragraph)\n            self._add_paragraph(target_page, paragraph, before_id=before_paragraph)\n\n    def _add_paragraph(self, page_id, paragraph, before_id):\n        paragraphs = self._pages[page_id][\"paragraphs\"]\n        if before_id is None:\n            paragraphs.append(paragraph)\n        else:\n            paragraphs.insert(index_with_id(paragraphs, before_id), paragraph)\n        self._paragraphs[paragraph[\"id\"]] = paragraph\n\n    def delete_paragraph(self, page_id, paragraph_id):\n        with self.notify():\n            paragraphs = self._pages[page_id][\"paragraphs\"]\n            paragraphs.pop(index_with_id(paragraphs, paragraph_id))\n            return self._paragraphs.pop(paragraph_id)\n\n    def edit_paragraph(self, paragraph_id, data):\n        with self.notify():\n            self._paragraphs[paragraph_id].update(data)\n",
"type":"code"
}
],
"title":"Document"
},
{
"children":[],
"id":"9e63791b51374f2c924e871da5ddc5d7",
"paragraphs":[
{
"id":"089ffcc884f348128bcba997655c9251",
"text":"Views provide a read only interface to a document. It is the only way to query a document.",
"type":"text"
},
{
"id":"eca45154b3f141c794c1cf1e56f273ee",
"path":[
"rliterate.py",
"<<classes>>",
"<<Document>>"
],
"text":"def get_page(self, page_id=None):\n    if page_id is None:\n        page_id = self.root_page[\"id\"]\n    page_dict = self._pages.get(page_id, None)\n    if page_dict is None:\n        return None\n    return DictPage(page_dict)\n",
"type":"code"
},
{
"id":"c73c7dd5a2804934a4786c1dd2a0b0d8",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class DictPage(object):\n\n    def __init__(self, page_dict):\n        self._page_dict = page_dict\n\n    @property\n    def id(self):\n        return self._page_dict[\"id\"]\n\n    @property\n    def title(self):\n        return self._page_dict[\"title\"]\n\n    @property\n    def paragraphs(self):\n        return [\n            DictParagraph.create(paragraph_dict)\n            for paragraph_dict\n            in self._page_dict[\"paragraphs\"]\n        ]\n\n    @property\n    def children(self):\n        return [\n            DictPage(child_dict)\n            for child_dict\n            in self._page_dict[\"children\"]\n        ]\n",
"type":"code"
},
{
"id":"da88f3daf0d742e394fc3be9d21f522f",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class DictParagraph(object):\n\n    @staticmethod\n    def create(paragraph_dict):\n        return {\n            \"text\": DictTextParagraph,\n            \"quote\": DictQuoteParagraph,\n            \"list\": DictListParagraph,\n            \"code\": DictCodeParagraph,\n        }.get(paragraph_dict[\"type\"], DictParagraph)(paragraph_dict)\n\n    def __init__(self, paragraph_dict):\n        self._paragraph_dict = paragraph_dict\n\n    @property\n    def id(self):\n        return self._paragraph_dict[\"id\"]\n\n    @property\n    def type(self):\n        return self._paragraph_dict[\"type\"]\n",
"type":"code"
},
{
"id":"0a73bece721f44899efa8c493dff8916",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class DictTextParagraph(DictParagraph):\n\n    @property\n    def filename(self):\n        return \"paragraph.txt\"\n\n    @property\n    def text(self):\n        return self._paragraph_dict[\"text\"]\n\n    @property\n    def formatted_text(self):\n        return DictTextParagraph.parse(self.text)\n\n    @staticmethod\n    def parse(text):\n        fragments = []\n        partial = \"\"\n        while text:\n            result = DictTextParagraph._get_special_fragment(text)\n            if result is None:\n                partial += text[0]\n                text = text[1:]\n            else:\n                match, fragment = result\n                if partial:\n                    fragments.append(Fragment(partial))\n                    partial = \"\"\n                fragments.append(fragment)\n                text = text[match.end(0):]\n        if partial:\n            fragments.append(Fragment(partial))\n        return fragments\n\n    PATTERNS = [\n        (\n            re.compile(r\"\\*\\*(.+?)\\*\\*\", flags=re.DOTALL),\n            lambda match: Fragment(\n                match.group(1),\n                token=Token.RLiterate.Strong\n            )\n        ),\n        (\n            re.compile(r\"\\*(.+?)\\*\", flags=re.DOTALL),\n            lambda match: Fragment(\n                match.group(1),\n                token=Token.RLiterate.Emphasis\n            )\n        ),\n        (\n            re.compile(r\"`(.+?)`\", flags=re.DOTALL),\n            lambda match: Fragment(\n                match.group(1),\n                token=Token.RLiterate.Code\n            )\n        ),\n        (\n            re.compile(r\"\\[(.+?)\\]\\((.+?)\\)\", flags=re.DOTALL),\n            lambda match: Fragment(\n                match.group(1),\n                token=Token.RLiterate.Link,\n                url=match.group(2)\n            )\n        ),\n    ]\n\n    @staticmethod\n    def _get_special_fragment(text):\n        for pattern, fn in DictTextParagraph.PATTERNS:\n            match = pattern.match(text)\n            if match:\n                return match, fn(match)\n",
"type":"code"
},
{
"id":"d100b29a782d4eba870356391b6b032d",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class DictQuoteParagraph(DictTextParagraph):\n    pass",
"type":"code"
},
{
"id":"688f0da89af846a2b2de0a9a131fab3e",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class DictListParagraph(DictTextParagraph):\n\n    @property\n    def item(self):\n        items, list_type = ListParser(self.text.strip().split(\"\\n\")).parse_items()\n        return ListItem(\"\", items, list_type)\n\n\nclass ListParser(object):\n\n    ITEM_START_RE = re.compile(r\"( *)([*]|\\d+[.]) (.*)\")\n\n    def __init__(self, lines):\n        self.lines = lines\n\n    def parse_items(self, level=0):\n        items = []\n        list_type = None\n        while True:\n            item_and_type = self.parse_item(level)\n            if item_and_type is None:\n                return items, list_type\n            else:\n                item, item_type = item_and_type\n                if list_type is None:\n                    list_type = item_type\n                items.append(item)\n\n    def parse_item(self, level):\n        parts = self.consume_bodies()\n        next_level = level + 1\n        item_type = None\n        if self.lines:\n            match = self.ITEM_START_RE.match(self.lines[0])\n            if match:\n                matched_level = len(match.group(1))\n                if matched_level >= level:\n                    parts.append(match.group(3))\n                    self.lines.pop(0)\n                    parts.extend(self.consume_bodies())\n                    next_level = matched_level + 1\n                    if \"*\" in match.group(2):\n                        item_type = \"unordered\"\n                    else:\n                        item_type = \"ordered\"\n        if parts:\n            children, child_type = self.parse_items(next_level)\n            return ListItem(DictTextParagraph.parse(\" \".join(parts)), children, child_type), item_type\n\n    def consume_bodies(self):\n        bodies = []\n        while self.lines:\n            if self.ITEM_START_RE.match(self.lines[0]):\n                break\n            else:\n                bodies.append(self.lines.pop(0))\n        return bodies\n\n\nclass ListItem(object):\n\n    def __init__(self, formatted_text, children, child_type):\n        self.formatted_text = formatted_text\n        self.children = children\n        self.child_type = child_type\n",
"type":"code"
},
{
"id":"40f7c112c54549b8851482fc2fafe614",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class DictCodeParagraph(DictParagraph):\n\n    @property\n    def text(self):\n        return self._paragraph_dict[\"text\"]\n\n    @property\n    def formatted_text(self):\n        try:\n            lexer = self._get_lexer()\n        except:\n            lexer = pygments.lexers.TextLexer(stripnl=False)\n        return self._tokens_to_fragments(lexer.get_tokens(self.text))\n\n    @property\n    def path(self):\n        return tuple(self._paragraph_dict[\"path\"])\n\n    @property\n    def filename(self):\n        last_part = \"\"\n        for part in self.path:\n            if part.startswith(\"<<\"):\n                break\n            last_part = part\n        return last_part\n\n    @property\n    def language(self):\n        try:\n            return \"\".join(self._get_lexer().aliases[:1])\n        except:\n            return \"\"\n\n    def _get_lexer(self):\n        return pygments.lexers.get_lexer_for_filename(\n            self.filename,\n            stripnl=False\n        )\n\n    def _tokens_to_fragments(self, tokens):\n        fragments = []\n        for token, text in tokens:\n            fragments.append(Fragment(text, token=token))\n        return fragments\n",
"type":"code"
},
{
"id":"75a8c2b60ac346e5be57b25dd5476f2d",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Fragment(object):\n\n    def __init__(self, text, token=Token.RLiterate, **extra):\n        self.text = text\n        self.token = token\n        self.extra = extra\n\n    def word_split(self):\n        fragments = []\n        text = self.text\n        while text:\n            match = re.match(r\".+?(\\s+|$)\", text, flags=re.DOTALL)\n            fragments.append(Fragment(text=match.group(0), token=self.token, **self.extra))\n            text = text[match.end(0):]\n        return fragments\n",
"type":"code"
}
],
"title":"Views"
}
],
"id":"276ff8047f7e46dea723c1822078ac26",
"paragraphs":[],
"title":"Document model"
},
{
"children":[],
"id":"f7f16199492c4bad80567c3a960b8bc9",
"paragraphs":[
{
"id":"9a3a290dceb54196a4d1b107d7634ce6",
"text":"A layout knows the visual state of the program. It for example knows what pages are expanded/collapsed in the table of contents and what is shown in the workspace.",
"type":"text"
},
{
"id":"48d620f5656a4a3c9acc813a4ce656d9",
"text":"The layout is recorded in a JSON object that is serialized to disk as soon as something changes.",
"type":"text"
},
{
"id":"e50b267f475a48d78b5ea92de3351960",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Layout(Observable):\n    <<Layout>>\n",
"type":"code"
},
{
"id":"5fa45b8aa7364565895d510ff7885da7",
"path":[
"rliterate.py",
"<<classes>>",
"<<Layout>>"
],
"text":"def __init__(self, path):\n    Observable.__init__(self)\n    self.listen(lambda event: write_json_to_file(path, self.data))\n    if os.path.exists(path):\n        self.data = load_json_from_file(path)\n    else:\n        self.data = {}\n    <<__init__>>\n",
"type":"code"
},
{
"id":"e76db32a5b6c45d8a05e036d12cf0c6c",
"text":"The rest of this class provides methods for reading and writing the `data` dict.",
"type":"text"
},
{
"id":"79a5b1ea5fa04b4db9e02ece3117e362",
"text":"The hoisted page is stored in `toc.hoisted_page_id`:",
"type":"text"
},
{
"id":"476b5bcbc1b540bb9ea853c3cbe6f590",
"path":[
"rliterate.py",
"<<classes>>",
"<<Layout>>",
"<<__init__>>"
],
"text":"self._toc = ensure_key(self.data, \"toc\", {})\n",
"type":"code"
},
{
"id":"e4c448026a024e2baaaeb19719227998",
"path":[
"rliterate.py",
"<<classes>>",
"<<Layout>>"
],
"text":"def get_hoisted_page(self):\n    return self._toc.get(\"hoisted_page_id\", None)\n\ndef set_hoisted_page(self, page_id):\n    with self.notify(\"toc\"):\n        self._toc[\"hoisted_page_id\"] = page_id\n",
"type":"code"
},
{
"id":"3d25d132c5f04df6b70d39fc30c7065e",
"text":"The collapsed pages are stored in `toc.collapsed`:",
"type":"text"
},
{
"id":"ae0c47bdc6a642fbb95bcc589b0cc9c7",
"path":[
"rliterate.py",
"<<classes>>",
"<<Layout>>",
"<<__init__>>"
],
"text":"self._toc_collapsed = ensure_key(self._toc, \"collapsed\", [])",
"type":"code"
},
{
"id":"8694cd469e844edda4ab47a8faf804f2",
"path":[
"rliterate.py",
"<<classes>>",
"<<Layout>>"
],
"text":"def is_collapsed(self, page_id):\n    return page_id in self._toc_collapsed\n\ndef toggle_collapsed(self, page_id):\n    with self.notify(\"toc\"):\n        if page_id in self._toc_collapsed:\n            self._toc_collapsed.remove(page_id)\n        else:\n            self._toc_collapsed.append(page_id)\n",
"type":"code"
},
{
"id":"a3a93f965d4349aba42893c4c7bba506",
"text":"The scratch pages are stored in `workspace.scratch`:",
"type":"text"
},
{
"id":"aa0db3fc90134e42ad571cbcc560730d",
"path":[
"rliterate.py",
"<<classes>>",
"<<Layout>>",
"<<__init__>>"
],
"text":"self._workspace = ensure_key(self.data, \"workspace\", {})\nself._workspace_scratch = ensure_key(self._workspace, \"scratch\", [])\n",
"type":"code"
},
{
"id":"b891da6a2e5641219278cb7f4a535f5e",
"path":[
"rliterate.py",
"<<classes>>",
"<<Layout>>"
],
"text":"def get_scratch_pages(self):\n    return self._workspace_scratch[:]\n\ndef set_scratch_pages(self, page_ids):\n    self.set_pages(page_ids, column_index=0)\n",
"type":"code"
},
{
"id":"881b5b9cc3f54fe381aa7862b804887a",
"text":"The pages displayed in the columns in the workspace are stored in `workspace.columns`:",
"type":"text"
},
{
"id":"0d83575340f24f67af49175cb0a1db83",
"path":[
"rliterate.py",
"<<classes>>",
"<<Layout>>",
"<<__init__>>"
],
"text":"self._workspace_columns = ensure_key(self._workspace, \"columns\", [])",
"type":"code"
},
{
"id":"d21e2540eb5547db8926f8b9e55ca2a7",
"path":[
"rliterate.py",
"<<classes>>",
"<<Layout>>"
],
"text":"@property\ndef columns(self):\n    if self._workspace_columns:\n        return [column[:] for column in self._workspace_columns]\n    else:\n        return [self.get_scratch_pages()]\n\ndef open_pages(self, page_ids, column_index=None):\n    with self.notify(\"workspace\"):\n        if column_index is None:\n            column_index = len(self._workspace_columns)\n        self._workspace_columns[column_index:] = [page_ids[:]]\n",
"type":"code"
},
{
"id":"dc91f34cfa6747119042fc7878702d88",
"text":"Finally we have a utility function for ensuring that a specific key exists in a dictionary.",
"type":"text"
},
{
"id":"0c4994ee9c5f4fdc84aa96dfad6df784",
"path":[
"rliterate.py",
"<<functions>>"
],
"text":"def ensure_key(a_dict, key, default):\n    if key not in a_dict:\n        a_dict[key] = default\n    return a_dict[key]\n",
"type":"code"
}
],
"title":"Layouts"
},
{
"children":[],
"id":"192db0d4b96e4162b3cf19f870ee287d",
"paragraphs":[
{
"id":"7ca054a5e8564724925b9af8044c94ad",
"text":"Some parts of the application can be themed. Token types from pygments denote different things that can be styled.",
"type":"text"
},
{
"id":"eb8c1e6d05664884b9404fd3bf68b315",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class BaseTheme(object):\n\n    def get_style(self, token_type):\n        if token_type in self.styles:\n            return self.styles[token_type]\n        return self.get_style(token_type.parent)\n",
"type":"code"
},
{
"id":"dbf00327a8ed40348d78004e82ef7d60",
"path":[
"rliterate.py",
"<<base classes>>"
],
"text":"class Style(object):\n\n    def __init__(self, color, bold=None, underlined=None, italic=False, monospace=False):\n        self.color = color\n        self.color_rgb = tuple([\n            int(x, 16)\n            for x\n            in (color[1:3], color[3:5], color[5:7])\n        ])\n        self.bold = bold\n        self.underlined = underlined\n        self.italic = italic\n        self.monospace = monospace\n\n    def apply_to_wx_dc(self, dc, base_font):\n        font = base_font\n        if self.bold:\n            font = font.Bold()\n        if self.underlined:\n            font = font.Underlined()\n        if self.italic:\n            font = font.Italic()\n        if self.monospace:\n            font = wx.Font(\n                pointSize=font.GetPointSize(),\n                family=wx.FONTFAMILY_TELETYPE,\n                style=font.GetStyle(),\n                weight=font.GetWeight(),\n                underline=font.GetUnderlined(),\n            )\n        dc.SetFont(font)\n        dc.SetTextForeground(self.color_rgb)\n",
"type":"code"
},
{
"id":"ba6b0fa60e1042d9a1a7c90b02be31a8",
"text":"Here is a theme based on solarized. Mostly stolen from https://github.com/honza/solarized-pygments/blob/master/solarized.py.",
"type":"text"
},
{
"id":"0f2a7a8d1dad436c826c16d47073d1dd",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class SolarizedTheme(BaseTheme):\n\n    base03  = \"#002b36\"\n    base02  = \"#073642\"\n    base01  = \"#586e75\"\n    base00  = \"#657b83\"\n    base0   = \"#839496\"\n    base1   = \"#93a1a1\"\n    base2   = \"#eee8d5\"\n    base3   = \"#fdf6e3\"\n    yellow  = \"#b58900\"\n    orange  = \"#cb4b16\"\n    red     = \"#dc322f\"\n    magenta = \"#d33682\"\n    violet  = \"#6c71c4\"\n    blue    = \"#268bd2\"\n    cyan    = \"#2aa198\"\n    green   = \"#859900\"\n\n    text    = \"#2e3436\"\n\n    styles = {\n        Token:                     Style(color=base00),\n        Token.Keyword:             Style(color=green),\n        Token.Keyword.Constant:    Style(color=cyan),\n        Token.Keyword.Declaration: Style(color=blue),\n        Token.Keyword.Namespace:   Style(color=orange),\n        Token.Name.Builtin:        Style(color=red),\n        Token.Name.Builtin.Pseudo: Style(color=blue),\n        Token.Name.Class:          Style(color=blue),\n        Token.Name.Decorator:      Style(color=blue),\n        Token.Name.Entity:         Style(color=violet),\n        Token.Name.Exception:      Style(color=yellow),\n        Token.Name.Function:       Style(color=blue),\n        Token.String:              Style(color=cyan),\n        Token.Number:              Style(color=cyan),\n        Token.Operator.Word:       Style(color=green),\n        Token.Comment:             Style(color=base1),\n        Token.RLiterate:           Style(color=text),\n        Token.RLiterate.Emphasis:  Style(color=text, italic=True),\n        Token.RLiterate.Strong:    Style(color=text, bold=True),\n        Token.RLiterate.Code:      Style(color=text, monospace=True),\n        Token.RLiterate.Link:      Style(color=blue, underlined=True),\n    }\n",
"type":"code"
}
],
"title":"Themes"
},
{
"children":[],
"id":"b376363cbd664a838d3bafb7bfae2281",
"paragraphs":[
{
"id":"af5fcddf1a684827aba22cb5ef8c2256",
"text":"A project is a container for a few other objects:",
"type":"text"
},
{
"id":"0ad6e197d56042de98b62fcfbba2f18b",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Project(Observable):\n\n    def __init__(self, filepath):\n        Observable.__init__(self)\n        self.theme = SolarizedTheme()\n        self.document = Document.from_file(filepath)\n        self.document.listen(self.notify_forwarder(\"document\"))\n        self.layout = Layout(\".{}.layout\".format(filepath))\n        self.layout.listen(self.notify_forwarder(\"layout\"))\n        FileGenerator().set_document(self.document)\n\n    <<Project>>\n",
"type":"code"
},
{
"id":"d88d38993f69435a955b4e3280dd28f0",
"text":"Wrapper methods for document:",
"type":"text"
},
{
"id":"d782b500e984468489cd876d5b92529d",
"path":[
"rliterate.py",
"<<classes>>",
"<<Project>>"
],
"text":"def get_page(self, *args, **kwargs):\n    return self.document.get_page(*args, **kwargs)\n\ndef add_page(self, *args, **kwargs):\n    return self.document.add_page(*args, **kwargs)\n\ndef delete_page(self, *args, **kwargs):\n    return self.document.delete_page(*args, **kwargs)\n\ndef move_page(self, *args, **kwargs):\n    return self.document.move_page(*args, **kwargs)\n\ndef edit_page(self, *args, **kwargs):\n    return self.document.edit_page(*args, **kwargs)\n\ndef add_paragraph(self, *args, **kwargs):\n    return self.document.add_paragraph(*args, **kwargs)\n\ndef move_paragraph(self, *args, **kwargs):\n    return self.document.move_paragraph(*args, **kwargs)\n\ndef delete_paragraph(self, *args, **kwargs):\n    return self.document.delete_paragraph(*args, **kwargs)\n\ndef edit_paragraph(self, *args, **kwargs):\n    return self.document.edit_paragraph(*args, **kwargs)\n",
"type":"code"
},
{
"id":"b08235caad29483791eaab31b81fb215",
"text":"Wrapper methods for layout:",
"type":"text"
},
{
"id":"82fdb1b7c5dc4a59909327365604260d",
"path":[
"rliterate.py",
"<<classes>>",
"<<Project>>"
],
"text":"def toggle_collapsed(self, *args, **kwargs):\n    return self.layout.toggle_collapsed(*args, **kwargs)\n\ndef is_collapsed(self, *args, **kwargs):\n    return self.layout.is_collapsed(*args, **kwargs)\n\ndef get_scratch_pages(self, *args, **kwargs):\n    return self.layout.get_scratch_pages(*args, **kwargs)\n\ndef set_scratch_pages(self, *args, **kwargs):\n    return self.layout.set_scratch_pages(*args, **kwargs)\n\n@property\ndef columns(self):\n    return self.layout.columns\n\ndef open_pages(self, *args, **kwargs):\n    return self.layout.open_pages(*args, **kwargs)\n\ndef get_hoisted_page(self, *args, **kwargs):\n    return self.layout.get_hoisted_page(*args, **kwargs)\n\ndef set_hoisted_page(self, *args, **kwargs):\n    return self.layout.set_hoisted_page(*args, **kwargs)\n",
"type":"code"
},
{
"id":"19a259c02d384479917bd03d8bd9a461",
"text":"Wrapper for theme:",
"type":"text"
},
{
"id":"462c206fa45f45dfa98e3d8154775365",
"path":[
"rliterate.py",
"<<classes>>",
"<<Project>>"
],
"text":"def get_style(self, *args, **kwargs):\n    return self.theme.get_style(*args, **kwargs)\n",
"type":"code"
}
],
"title":"Project"
},
{
"children":[
{
"children":[],
"id":"56b835fee5b24f8a8e59156506ac6464",
"paragraphs":[
{
"id":"4c422e0326ee44c8ad863ee71d8d07b5",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class FileGenerator(object):\n\n    def __init__(self):\n        self.listener = Listener(lambda event: self._generate())\n\n    def set_document(self, document):\n        self.document = document\n        self.listener.set_observable(self.document)\n\n    def _generate(self):\n        self._parts = defaultdict(list)\n        self._collect_parts(self.document.get_page())\n        self._generate_files()\n\n    def _collect_parts(self, page):\n        for paragraph in page.paragraphs:\n            if paragraph.type == \"code\":\n                for line in paragraph.text.splitlines():\n                    self._parts[paragraph.path].append(line)\n        for child in page.children:\n            self._collect_parts(child)\n\n    def _generate_files(self):\n        for key in self._parts.keys():\n            filepath = self._get_filepath(key)\n            if filepath is not None:\n                with open(filepath, \"w\") as f:\n                    self._render(f, key)\n\n    def _render(self, f, key, prefix=\"\"):\n        for line in self._parts[key]:\n            match = re.match(r\"^(\\s*)(<<.*>>)\\s*$\", line)\n            if match:\n                self._render(f, key + (match.group(2),), prefix=prefix+match.group(1))\n            else:\n                if len(line) > 0:\n                    f.write(prefix)\n                    f.write(line)\n                f.write(\"\\n\")\n\n    def _get_filepath(self, key):\n        if len(key) == 0:\n            return None\n        for part in key:\n            if part.startswith(\"<<\") and part.endswith(\">>\"):\n                return None\n        return os.path.join(*key)",
"type":"code"
}
],
"title":"Code files"
},
{
"children":[],
"id":"162d5b5c668d4c958c88b7d37e6f5d3e",
"paragraphs":[
{
"id":"1dc61da331924d68982c1a73b9fe1f02",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class HTMLBuilder(object):\n\n    def __init__(self, document, **options):\n        self.document = document\n        self.parts = []\n        self.generate_toc = options.get(\"generate_toc\", True)\n        self.toc_max_depth = options.get(\"toc_max_depth\", 3)\n\n    def build(self):\n        self.page(self.document.get_page())\n        return \"\".join(self.parts)\n\n    def toc(self, root_page, levels_left):\n        if levels_left > 0:\n            with self.tag(\"ul\", newlines=False):\n                for page in root_page.children:\n                    with self.tag(\"li\", newlines=False):\n                        with self.tag(\"a\", newlines=False, args={\"href\": \"#{}\".format(page.id)}):\n                            self.escaped(page.title)\n                            self.toc(page, levels_left - 1)\n\n    def page(self, page, level=1):\n        with self.tag(\"h{}\".format(level)):\n            if level > 1 and level <= self.toc_max_depth+1:\n                with self.tag(\"a\", args={\"name\": page.id}):\n                    pass\n            self.escaped(page.title)\n        for paragraph in page.paragraphs:\n            {\n                \"text\": self.paragraph_text,\n                \"quote\": self.paragraph_quote,\n                \"list\": self.paragraph_list,\n                \"code\": self.paragraph_code,\n            }.get(paragraph.type, self.paragraph_unknown)(paragraph)\n        if level == 1 and self.generate_toc:\n            self.toc(page, self.toc_max_depth)\n        for child in page.children:\n            self.page(child, level+1)\n\n    def paragraph_text(self, text):\n        with self.tag(\"p\"):\n            self.fragments(text.formatted_text)\n\n    def paragraph_quote(self, text):\n        with self.tag(\"blockquote\"):\n            self.fragments(text.formatted_text)\n\n    def paragraph_list(self, paragraph):\n        self.list(paragraph.item)\n\n    def list(self, a_list):\n        if a_list.children:\n            with self.tag({\"ordered\": \"ol\"}.get(a_list.child_type, \"ul\")):\n                for item in a_list.children:\n                    with self.tag(\"li\"):\n                        self.fragments(item.formatted_text)\n                        self.list(item)\n\n    def fragments(self, fragments):\n        for fragment in fragments:\n            {\n                Token.RLiterate.Emphasis: self.fragment_emphasis,\n                Token.RLiterate.Strong: self.fragment_strong,\n                Token.RLiterate.Code: self.fragment_code,\n                Token.RLiterate.Link: self.fragment_link,\n            }.get(fragment.token, self.fragment_default)(fragment)\n\n    def fragment_emphasis(self, fragment):\n        with self.tag(\"em\", newlines=False):\n            self.escaped(fragment.text)\n\n    def fragment_strong(self, fragment):\n        with self.tag(\"strong\", newlines=False):\n            self.escaped(fragment.text)\n\n    def fragment_code(self, fragment):\n        with self.tag(\"code\", newlines=False):\n            self.escaped(fragment.text)\n\n    def fragment_link(self, fragment):\n        with self.tag(\"a\", args={\"href\": fragment.extra[\"url\"]}, newlines=False):\n            self.escaped(fragment.text)\n\n    def fragment_default(self, fragment):\n        self.escaped(fragment.text)\n\n    def paragraph_code(self, code):\n        with self.tag(\"p\"):\n            with self.tag(\"code\", newlines=False):\n                self.escaped(\" / \".join(code.path))\n        with self.tag(\"div\", args={\"class\": \"highlight\"}):\n            with self.tag(\"pre\", newlines=False):\n                for fragment in code.formatted_text:\n                    with self.tag(\n                        \"span\",\n                        newlines=False,\n                        args={\"class\": STANDARD_TYPES.get(fragment.token, \"\")}\n                    ):\n                        self.escaped(fragment.text)\n\n    def paragraph_unknown(self, paragraph):\n        with self.tag(\"p\"):\n            self.escaped(\"Unknown paragraph...\")\n\n    @contextlib.contextmanager\n    def tag(self, tag, newlines=True, args={}):\n        args_string = \"\"\n        if args:\n            args_string = \" \" + \" \".join(\"{}=\\\"{}\\\"\".format(k, v) for k, v in args.items())\n        self.raw(\"<{}{}>\".format(tag, args_string))\n        yield\n        self.raw(\"</{}>\".format(tag))\n        if newlines:\n            self.raw(\"\\n\\n\")\n\n    def raw(self, text):\n        self.parts.append(text)\n\n    def escaped(self, text):\n        self.parts.append(xml.sax.saxutils.escape(text))\n",
"type":"code"
}
],
"title":"HTML"
},
{
"children":[],
"id":"427cb0d170a04b9898b5b744cd15b263",
"paragraphs":[
{
"id":"324a5ebb37a44ec49c685670205356a5",
"text":"This generates a file that is suitable for textual diffing.",
"type":"text"
},
{
"id":"7c76089d9db94d88b845c160fe2d249c",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class DiffBuilder(object):\n\n    def __init__(self, document):\n        self.document = document\n\n    def build(self):\n        self.parts = []\n        self._foo()\n        return \"\".join(self.parts)\n\n    def _foo(self):\n        self.pages = []\n        self._collect_pages(self.document.get_page())\n        self._render_pages()\n\n    def _collect_pages(self, page):\n        self.pages.append(page)\n        for child in page.children:\n            self._collect_pages(child)\n\n    def _render_pages(self):\n        for page in sorted(self.pages, key=lambda page: page.id):\n            self._write(page.id)\n            self._write(\": \")\n            self._write(page.title)\n            self._write(\"\\n\\n\")\n            for paragraph in page.paragraphs:\n                {\n                    \"text\": self._render_text,\n                    \"quote\": self._render_quote,\n                    \"code\": self._render_code,\n                }.get(paragraph.type, self._render_unknown)(paragraph)\n\n    def _render_text(self, text):\n        self._wrapped_text(text.text+\"\\n\\n\")\n\n    def _render_quote(self, text):\n        self._wrapped_text(text.text+\"\\n\\n\", indent=4)\n\n    def _wrapped_text(self, text, indent=0):\n        current_line = []\n        for part in text.replace(\"\\n\", \" \").split(\" \"):\n            if len(\" \".join(current_line)) > 60-indent:\n                self._write(\" \"*indent+\" \".join(current_line))\n                self._write(\"\\n\")\n                current_line = []\n            if part.strip():\n                current_line.append(part.strip())\n        if current_line:\n            self._write(\" \"*indent+\" \".join(current_line))\n            self._write(\"\\n\")\n        self._write(\"\\n\")\n\n    def _render_code(self, code):\n        self._write(\"`\"+\" / \".join(code.path)+\"`:\\n\\n\")\n        for line in code.text.splitlines():\n            self._write(\"    \"+line+\"\\n\")\n        self._write(\"\\n\\n\")\n\n    def _render_unknown(self, paragraph):\n        self._write(\"Unknown type = \"+paragraph.type+\"\\n\\n\")\n\n    def _write(self, text):\n        self.parts.append(text)\n",
"type":"code"
}
],
"title":"Textual diffing"
}
],
"id":"63ff2f7abea44406922c78b7683e2dd3",
"paragraphs":[],
"title":"Generating output"
},
{
"children":[],
"id":"01aa28a581e84f088104c6cd600d9c1d",
"paragraphs":[
{
"id":"8f8ab8583e3744868ed12bfbd36c1090",
"path":[
"rliterate.py",
"<<base classes>>"
],
"text":"class Observable(object):\n\n    def __init__(self):\n        self._notify_count = 0\n        self._listeners = []\n\n    def listen(self, fn, *events):\n        self._listeners.append((fn, events))\n\n    def unlisten(self, fn, *events):\n        self._listeners.remove((fn, events))\n\n    @contextlib.contextmanager\n    def notify(self, event=\"\"):\n        self._notify_count += 1\n        try:\n            yield\n        finally:\n            self._notify_count -= 1\n            self._notify(event)\n\n    def notify_forwarder(self, prefix):\n        def forwarder(event):\n            self._notify(\"{}.{}\".format(prefix, event))\n        return forwarder\n\n    def _notify(self, event):\n        if self._notify_count == 0:\n            for fn, fn_events in self._listeners:\n                if self._is_match(fn_events, event):\n                    fn(event)\n\n    def _is_match(self, fn_events, event):\n        if len(fn_events) == 0:\n            return True\n        for fn_event in fn_events:\n            if is_prefix(fn_event.split(\".\"), event.split(\".\")):\n                return True\n        return False\n",
"type":"code"
},
{
"id":"56eaa5b767f44049b536742e79bd22ce",
"path":[
"rliterate.py",
"<<functions>>"
],
"text":"def is_prefix(left, right):\n    return left == right[:len(left)]",
"type":"code"
},
{
"id":"bc097616885847ec889aa3b44a2af116",
"path":[
"rliterate.py",
"<<classes>>"
],
"text":"class Listener(object):\n\n    def __init__(self, fn, *events):\n        self.fn = fn\n        self.events = events\n        self.observable = None\n\n    def set_observable(self, observable):\n        if self.observable is not None:\n            self.observable.unlisten(self.fn, *self.events)\n        self.observable = observable\n        self.observable.listen(self.fn, *self.events)\n        self.fn(\"\")\n",
"type":"code"
}
],
"title":"Publish subscribe mechanisms"
},
{
"children":[],
"id":"b73b797520334653a235e5e6a077e573",
"paragraphs":[
{
"id":"e9d4a6d5641f42c69cb2452d44bea386",
"path":[
"rliterate.py",
"<<functions>>"
],
"text":"def load_json_from_file(path):\n    with open(path, \"r\") as f:\n        return json.load(f)\n",
"type":"code"
},
{
"id":"1d090bee1c344ef8872251856361d2be",
"path":[
"rliterate.py",
"<<functions>>"
],
"text":"def write_json_to_file(path, data):\n    with safely_write_file(path) as f:\n        json.dump(\n            data, f,\n            sort_keys=True, indent=0, separators=(',', ':')\n        )\n",
"type":"code"
},
{
"id":"650c09f63833430891ca9b67e3dd2db9",
"text":"This functions tries to write safely to a file. The file will either be completely written or not modified at all. It is achieved by first writing to a temporary file and then performing a rename.",
"type":"text"
},
{
"id":"fb0a3d697605402caa3fa448c3b93b67",
"path":[
"rliterate.py",
"<<functions>>"
],
"text":"@contextlib.contextmanager\ndef safely_write_file(path):\n    with tempfile.NamedTemporaryFile(\n        dir=os.path.dirname(path),\n        prefix=os.path.basename(path) + \".tmp\",\n        delete=False\n    ) as tmp:\n        yield tmp\n    os.rename(tmp.name, path)",
"type":"code"
}
],
"title":"JSON serialization mechanisms"
},
{
"children":[],
"id":"fddc930e6caa4a38bf6e7259e6e1034a",
"paragraphs":[
{
"id":"9cb2e56cf6dc4a5f98fdbc5fcbdaa159",
"path":[
"rliterate.py",
"<<functions>>"
],
"text":"def genid():\n    return uuid.uuid4().hex\n\n\ndef create_font(monospace=False, size=10, bold=False):\n    return wx.Font(\n        size,\n        wx.FONTFAMILY_TELETYPE if monospace else wx.FONTFAMILY_DEFAULT,\n        wx.FONTSTYLE_NORMAL,\n        wx.FONTWEIGHT_BOLD if bold else wx.FONTWEIGHT_NORMAL,\n        False\n    )\n\n\ndef find_first(items, action):\n    for item in items:\n        result = action(item)\n        if result is not None:\n            return result\n    return None\n\n\ndef pairs(items):\n    return zip(items, items[1:]+[None])\n\n\ndef min_or_none(items, key):\n    if not items:\n        return None\n    return min(items, key=key)\n\n\ndef index_with_id(items, item_id):\n    for index, item in enumerate(items):\n        if item[\"id\"] == item_id:\n            return index",
"type":"code"
},
{
"id":"45cbdbd53c2d4822b9f771ff5e786f55",
"path":[
"rliterate.py",
"<<functions>>"
],
"text":"def edit_in_gvim(text, filename):\n    with tempfile.NamedTemporaryFile(suffix=\"-rliterate-external-\"+filename) as f:\n        f.write(text)\n        f.flush()\n        p = subprocess.Popen([\"gvim\", \"--nofork\", f.name])\n        while p.poll() is None:\n            wx.Yield()\n            time.sleep(0.1)\n        f.seek(0)\n        return f.read()\n",
"type":"code"
}
],
"title":"Functions"
},
{
"children":[],
"id":"745dcf0d093a4f179dc7fbe1dc8b7bdd",
"paragraphs":[
{
"id":"93f40cf2b3364e0ca390f5cb0239ce0a",
"path":[
"rliterate.py"
],
"text":"from collections import defaultdict\nimport contextlib\nimport json\nimport os\nimport re\nimport subprocess\nimport sys\nimport tempfile\nimport time\nimport uuid\nimport webbrowser\nimport xml.sax.saxutils\n\nimport pygments.lexers\nfrom pygments.token import Token, STANDARD_TYPES\nimport wx\nimport wx.lib.newevent\n\n\n<<constants>>\n<<base classes 1>>\n<<base classes>>\n<<classes>>\n<<functions>>\n\n\nif __name__ == \"__main__\":\n    if sys.argv[2:] == [\"--html\"]:\n        sys.stdout.write(HTMLBuilder(Document.from_file(sys.argv[1])).build())\n    elif sys.argv[2:] == [\"--diff\"]:\n        sys.stdout.write(DiffBuilder(Document.from_file(sys.argv[1])).build())\n    else:\n        app = wx.App()\n        main_frame = MainFrame(filepath=sys.argv[1])\n        main_frame.Show()\n        app.MainLoop()\n",
"type":"code"
}
],
"title":"Main Python file"
}
],
"id":"4d689acb540d40ecb8b828701bb5bf74",
"paragraphs":[
{
"id":"658e04c3d7394bca90f06344f85dfd24",
"text":"RLiterate is implemented in Python. This chapter gives a complete description of all the code.",
"type":"text"
}
],
"title":"Implementation"
},
{
"children":[
{
"children":[],
"id":"85bb3ad476d540bb8b6bfed905d158f0",
"paragraphs":[
{
"id":"4cc12cc77623452782cf8a37f8ba6e52",
"text":"If `*.rliterate` documents are version controlled, the textual diff is hard to read. This problem can be sovled in Git by defining a textconv command that converts the `*.rliterate` document to text that is suitable for diffing. The `--diff` option to RLiterate outputs a document in a textual diff friendly format.",
"type":"text"
},
{
"id":"dbb16270187643a3978ee8aac0b16d8a",
"text":"First associate `*.rliterate` files with `rliterate`. This file gos into your repository.",
"type":"text"
},
{
"id":"ca1d82459a9041689a51503bec437f67",
"path":[
".gitattributes"
],
"text":"*.rliterate diff=rliterate",
"type":"code"
},
{
"id":"c69258a42b6c449c95a310a041f1c6ec",
"text":"Then define the `textconv` command in your git config:",
"type":"text"
},
{
"id":"3443fd22d8824369b1bdba19d4c4c361",
"path":[
"<<.gitconfig>>"
],
"text":"[diff \"rliterate\"]\n      textconv=bash -c 'python $RLITERATE_ROOT/rliterate.py \"$0\" --diff'",
"type":"code"
}
],
"title":"Diffing"
}
],
"id":"28b1947216874cedaf4ea69c2e2574b4",
"paragraphs":[],
"title":"Development"
},
{
"children":[],
"id":"cc36000ed12f4bfe88cefa2987fdb5cd",
"paragraphs":[
{
"id":"fda934bcd2ed4bb9b24a22fde654ded5",
"text":"DoDragDrop must be called from within an event handler.",
"type":"text"
},
{
"id":"aea413d004a34a7b8afeb35129a82cb6",
"text":"Font must be assigned before setting a label, otherwise size calculations will be wrong? Must investigate further.",
"type":"text"
}
],
"title":"Things I learned"
},
{
"children":[],
"id":"0a165f3042ee4350b9bebb61213b44c5",
"paragraphs":[
{
"id":"de3589c301134bd88a37a3836dfd330e",
"text":"Random notes of what I might want to work on in the future.",
"type":"text"
},
{
"id":"334a278ca527447482c3059353cfed4f",
"text":"* Multiple editors can be opened (only last opened is saved)\n* Factory should drop right into edit mode\n* Highlighting of toc rows is not always up to date\n* Invalid drop targets are still shown\n    * Hide dragged item?\n* Code editor\n    * Tab indents with tab: should indent 4 spaces?\n    * Shift+Tab deletes: should dedent\n* Normalize paragraph when saving\n    * Split into multiple paragraphs on more than one newline\n    * Remove single newlines\n    * Remove paragraph if text is empty\n* Missing page operations\n    * Add (before, after)\n* Missing paragraph operations\n    * Context menu with add paragraph before/after\n* File generator writes empty filename\n* There is no way to control empty lines from placeholders\n* There is no list paragraph type\n* Save button (in code editor) is very far down if there is lots of code and only top is edited\n* Not possible to go to a page with Ctrl+T\n* Highlight object being dragged somehow (screenshot?)\n* Save when clicking outside text field (how to do this?)\n* This is really a writing tool\n    * Spell checking\n* Final test: rewrite rlselect (or other program) using rliterate\n    1. Import all source code as is\n    2. Write narrative\n    3. Ensure generated files are not changed\n* Highlight active page in TOC\n* Right click should only be generated on up if first down\n* Workspace should not be wider that a column, that creates an unnecessary scrollbar\n* Literate programming treats any target programming language as an assembly language\n* TOC should only expand first 3(?) levels when opening a file for the first time\n* Deleting root (even hoisted root) gives error\n* Reading tool: Code can either be read in chunks or the final output. And you can follow links between them.\n* Undo (use immutable data types (pyrsistent?))\n* Diff two rliterate documents\n* Search and replace\n* Highlight placeholders in code fragments\n* `word_split` should put white space in separate fragment and rich text display should have `skip_leading_space` option\n* Export to stand-alone html for use in blog\n* Drag and drop does not work om Mac (incorrect coordinate calculations?)\n* Dynamic scripting\n    * Show graph paragraph based on data paragraph defined earlier on the page (or on other page)\n* Editors: highlight the word/fragment that is double clicked\n* Paragraph editor has comment: extract comment to prose\n* List code is messy\n* Max height on editors?",
"type":"list"
}
],
"title":"TODO"
}
],
"id":"956ae4613f144e3581d420995a7ef046",
"paragraphs":[
{
"id":"fb1a6842fe1f4642a2aa21113a2ad179",
"text":"RLiterate is a tool for reading and authoring documents. Documents have pages organized in a hierarchy. Pages have a title and paragraphs. Paragraphs can be of different types. The different paragraph types is what make RLiterate documents special. Code paragraphs for example enable literate programming by allowing chunks of code to be defined and then be automatically assembled into the final source file. Text paragraphs are used for writing prose. RLiterate documents can also be exported to different formats for display in different mediums.\n",
"type":"text"
},
{
"id":"79a11727fbb540ec86bfe64f4ac740bc",
"text":"This book explains RLiterate and also includes the complete implementation of the program.",
"type":"text"
}
],
"title":"RLiterate"
}